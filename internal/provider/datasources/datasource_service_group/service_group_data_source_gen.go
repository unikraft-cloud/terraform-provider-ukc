// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_service_group

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ServiceGroupDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"service_groups": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"autoscale": schema.BoolAttribute{
									Computed:            true,
									Description:         "Indicates if the service has autoscale enabled.  See the associated\nautoscale documentation for more information about how to set this up.\nAutoscale policies can be set up after the service has been created.",
									MarkdownDescription: "Indicates if the service has autoscale enabled.  See the associated\nautoscale documentation for more information about how to set this up.\nAutoscale policies can be set up after the service has been created.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The time the service was created.",
									MarkdownDescription: "The time the service was created.",
								},
								"domains": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"certificate": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"common_name": schema.StringAttribute{
														Computed: true,
													},
													"created_at": schema.StringAttribute{
														Computed:            true,
														Description:         "The time the certificate was created.",
														MarkdownDescription: "The time the certificate was created.",
													},
													"name": schema.StringAttribute{
														Computed:            true,
														Description:         "The name of the certificate.\n\nThis is a human-readable name that can be used to identify the certificate.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the certificate in API calls.",
														MarkdownDescription: "The name of the certificate.\n\nThis is a human-readable name that can be used to identify the certificate.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the certificate in API calls.",
													},
													"state": schema.StringAttribute{
														Computed: true,
													},
													"uuid": schema.StringAttribute{
														Computed:            true,
														Description:         "The UUID of the certificate.\n\nThis is a unique identifier for the certificate that is generated when the\ncertificate is created.  The UUID is used to reference the certificate in\nAPI calls and can be used to identify the certificate in all API calls that\nrequire an identifier.",
														MarkdownDescription: "The UUID of the certificate.\n\nThis is a unique identifier for the certificate that is generated when the\ncertificate is created.  The UUID is used to reference the certificate in\nAPI calls and can be used to identify the certificate in all API calls that\nrequire an identifier.",
													},
												},
												CustomType: CertificateType{
													ObjectType: types.ObjectType{
														AttrTypes: CertificateValue{}.AttributeTypes(ctx),
													},
												},
												Computed: true,
											},
											"fqdn": schema.StringAttribute{
												Computed:            true,
												Description:         "Publicly accessible domain name. If this name ends in a period `.` it must\nbe a valid Full Qualified Domain Name (FQDN), otherwise it will become a\nsubdomain of the target metro.",
												MarkdownDescription: "Publicly accessible domain name. If this name ends in a period `.` it must\nbe a valid Full Qualified Domain Name (FQDN), otherwise it will become a\nsubdomain of the target metro.",
											},
										},
										CustomType: DomainsType{
											ObjectType: types.ObjectType{
												AttrTypes: DomainsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of domains associated with the service.  Domains are used to access\nthe service over the Internet.",
									MarkdownDescription: "List of domains associated with the service.  Domains are used to access\nthe service over the Internet.",
								},
								"hard_limit": schema.Int64Attribute{
									Computed:            true,
									Description:         "The hard limit defines the maximum number of concurrent requests that an\ninstance assigned to the this service can handle.  The load balancer will\nnever assign more requests to a single instance.  In case there are no\nother instances available, excess requests fail (i.e., they are blocked and\nnot queued).",
									MarkdownDescription: "The hard limit defines the maximum number of concurrent requests that an\ninstance assigned to the this service can handle.  The load balancer will\nnever assign more requests to a single instance.  In case there are no\nother instances available, excess requests fail (i.e., they are blocked and\nnot queued).",
								},
								"instances": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed:            true,
												Description:         "The name of the instance.  This is a human-readable name that can be used\nto identify the instance.  The name must be unique within the context of\nyour account.  If no name is specified, a random name is generated for\nyou.  The name can also be used to identify the instance in API calls.",
												MarkdownDescription: "The name of the instance.  This is a human-readable name that can be used\nto identify the instance.  The name must be unique within the context of\nyour account.  If no name is specified, a random name is generated for\nyou.  The name can also be used to identify the instance in API calls.",
											},
											"uuid": schema.StringAttribute{
												Computed:            true,
												Description:         "The UUID of the instance.  This is a unique identifier for the instance\nthat is generated when the instance is created.  The UUID is used to\nreference the instance in API calls and can be used to identify the\ninstance in all API calls that require an instance identifier.",
												MarkdownDescription: "The UUID of the instance.  This is a unique identifier for the instance\nthat is generated when the instance is created.  The UUID is used to\nreference the instance in API calls and can be used to identify the\ninstance in all API calls that require an instance identifier.",
											},
										},
										CustomType: InstancesType{
											ObjectType: types.ObjectType{
												AttrTypes: InstancesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of instances assigned to the service.",
									MarkdownDescription: "List of instances assigned to the service.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of the service group.\n\nThis is a human-readable name that can be used to identify the service\ngroup. The name must be unique within the context of your account.  The\nname can also be used to identify the service in API calls.",
									MarkdownDescription: "The name of the service group.\n\nThis is a human-readable name that can be used to identify the service\ngroup. The name must be unique within the context of your account.  The\nname can also be used to identify the service in API calls.",
								},
								"persistent": schema.BoolAttribute{
									Computed:            true,
									Description:         "Indicates if the service will stay remain even after the last instance\ndetached.  If this is set to false, the service will be deleted when the\nlast instance detached from it.  If this is set to true, the service will\nremain and can be reused by other instances.  This is useful if you want to\nkeep the service configuration, e.g., the published ports, handlers, and\ndomains, even if there are no instances assigned to it.",
									MarkdownDescription: "Indicates if the service will stay remain even after the last instance\ndetached.  If this is set to false, the service will be deleted when the\nlast instance detached from it.  If this is set to true, the service will\nremain and can be reused by other instances.  This is useful if you want to\nkeep the service configuration, e.g., the published ports, handlers, and\ndomains, even if there are no instances assigned to it.",
								},
								"services": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"destination_port": schema.Int64Attribute{
												Computed:            true,
												Description:         "The port number that the instance is listening on.  This is the internal\nport which Unikraft Cloud will forward traffic to.",
												MarkdownDescription: "The port number that the instance is listening on.  This is the internal\nport which Unikraft Cloud will forward traffic to.",
											},
											"handlers": schema.ListAttribute{
												ElementType:         types.StringType,
												Computed:            true,
												Description:         "Connection handlers to use for the service.  Handlers define how the\nservice will handle incoming connections and forward traffic from the\nInternet to your application.  For example, a service can be configured\nto terminate TLS connections, redirect HTTP traffic, or enable HTTP mode\nfor load balancing.  You configure the handlers for every published\nservice port individually.",
												MarkdownDescription: "Connection handlers to use for the service.  Handlers define how the\nservice will handle incoming connections and forward traffic from the\nInternet to your application.  For example, a service can be configured\nto terminate TLS connections, redirect HTTP traffic, or enable HTTP mode\nfor load balancing.  You configure the handlers for every published\nservice port individually.",
											},
											"port": schema.Int64Attribute{
												Computed:            true,
												Description:         "This is the public-facing port that the service will be accessible from\non the Internet.",
												MarkdownDescription: "This is the public-facing port that the service will be accessible from\non the Internet.",
											},
										},
										CustomType: ServicesType{
											ObjectType: types.ObjectType{
												AttrTypes: ServicesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of published network ports for this service and the destination port\nto which Unikraft Cloud will forward traffic to.  Additional handlers can\nbe defined for each published port in order to define how the service will\nhandle incoming connections and forward traffic from the Internet to your\napplication.  For example, a service can be configured to terminate TLS\nconnections, redirect HTTP traffic, or enable HTTP mode for load balancing.",
									MarkdownDescription: "List of published network ports for this service and the destination port\nto which Unikraft Cloud will forward traffic to.  Additional handlers can\nbe defined for each published port in order to define how the service will\nhandle incoming connections and forward traffic from the Internet to your\napplication.  For example, a service can be configured to terminate TLS\nconnections, redirect HTTP traffic, or enable HTTP mode for load balancing.",
								},
								"soft_limit": schema.Int64Attribute{
									Computed:            true,
									Description:         "The soft limit is used by the Unikraft Cloud load balancer to decide when\nto wake up another standby instance.  For example, if the soft limit is set\nto 5 and the service consists of 2 standby instances, one of the instances\nreceives up to 5 concurrent requests.  The 6th parallel requests wakes up\nthe second instance.  If there are no more standby instances to wake up,\nthe number of requests assigned to each instance will exceed the soft\nlimit.  The load balancer makes sure that when the number of in-flight\nrequests goes down again, instances are put into standby as fast as\npossible.",
									MarkdownDescription: "The soft limit is used by the Unikraft Cloud load balancer to decide when\nto wake up another standby instance.  For example, if the soft limit is set\nto 5 and the service consists of 2 standby instances, one of the instances\nreceives up to 5 concurrent requests.  The 6th parallel requests wakes up\nthe second instance.  If there are no more standby instances to wake up,\nthe number of requests assigned to each instance will exceed the soft\nlimit.  The load balancer makes sure that when the number of in-flight\nrequests goes down again, instances are put into standby as fast as\npossible.",
								},
								"uuid": schema.StringAttribute{
									Computed:            true,
									Description:         "The UUID of the service group.\n\nThis is a unique identifier for the service group that is generated when\nthe service group is created.  The UUID is used to reference the service in\nAPI calls and can be used to identify the service group in all API calls\nthat require an identifier.",
									MarkdownDescription: "The UUID of the service group.\n\nThis is a unique identifier for the service group that is generated when\nthe service group is created.  The UUID is used to reference the service in\nAPI calls and can be used to identify the service group in all API calls\nthat require an identifier.",
								},
							},
							CustomType: ServiceGroupsType{
								ObjectType: types.ObjectType{
									AttrTypes: ServiceGroupsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "The service group(s) which were retrieved by the request.",
						MarkdownDescription: "The service group(s) which were retrieved by the request.",
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "The response data for this request.",
				MarkdownDescription: "The response data for this request.",
			},
			"details": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to include details about the service group in the response.  By\ndefault this is set to true, meaning that all information about the service\ngroup will be included in the response.  If set to false, only the basic\ninformation about the service group will be included, such as its name and\nUUID.",
				MarkdownDescription: "Whether to include details about the service group in the response.  By\ndefault this is set to true, meaning that all information about the service\ngroup will be included in the response.  If set to false, only the basic\ninformation about the service group will be included, such as its name and\nUUID.",
			},
			"message": schema.StringAttribute{
				Computed:            true,
				Description:         "An optional message providing additional information about the response.",
				MarkdownDescription: "An optional message providing additional information about the response.",
			},
			"op_time_us": schema.Int64Attribute{
				Computed:            true,
				Description:         "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
				MarkdownDescription: "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "The status of the response.",
				MarkdownDescription: "The status of the response.",
			},
		},
	}
}

type ServiceGroupModel struct {
	Data     DataValue    `tfsdk:"data"`
	Details  types.Bool   `tfsdk:"details"`
	Message  types.String `tfsdk:"message"`
	OpTimeUs types.Int64  `tfsdk:"op_time_us"`
	Status   types.String `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	serviceGroupsAttribute, ok := attributes["service_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_groups is missing from object`)

		return nil, diags
	}

	serviceGroupsVal, ok := serviceGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_groups expected to be basetypes.ListValue, was: %T`, serviceGroupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		ServiceGroups: serviceGroupsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	serviceGroupsAttribute, ok := attributes["service_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_groups is missing from object`)

		return NewDataValueUnknown(), diags
	}

	serviceGroupsVal, ok := serviceGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_groups expected to be basetypes.ListValue, was: %T`, serviceGroupsAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		ServiceGroups: serviceGroupsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	ServiceGroups basetypes.ListValue `tfsdk:"service_groups"`
	state         attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["service_groups"] = basetypes.ListType{
		ElemType: ServiceGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ServiceGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	serviceGroups := types.ListValueMust(
		ServiceGroupsType{
			basetypes.ObjectType{
				AttrTypes: ServiceGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.ServiceGroups.Elements(),
	)

	if v.ServiceGroups.IsNull() {
		serviceGroups = types.ListNull(
			ServiceGroupsType{
				basetypes.ObjectType{
					AttrTypes: ServiceGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ServiceGroups.IsUnknown() {
		serviceGroups = types.ListUnknown(
			ServiceGroupsType{
				basetypes.ObjectType{
					AttrTypes: ServiceGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"service_groups": basetypes.ListType{
			ElemType: ServiceGroupsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"service_groups": serviceGroups,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ServiceGroups.Equal(other.ServiceGroups) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"service_groups": basetypes.ListType{
			ElemType: ServiceGroupsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ServiceGroupsType{}

type ServiceGroupsType struct {
	basetypes.ObjectType
}

func (t ServiceGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceGroupsType) String() string {
	return "ServiceGroupsType"
}

func (t ServiceGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoscaleAttribute, ok := attributes["autoscale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autoscale is missing from object`)

		return nil, diags
	}

	autoscaleVal, ok := autoscaleAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autoscale expected to be basetypes.BoolValue, was: %T`, autoscaleAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return nil, diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	hardLimitAttribute, ok := attributes["hard_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hard_limit is missing from object`)

		return nil, diags
	}

	hardLimitVal, ok := hardLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hard_limit expected to be basetypes.Int64Value, was: %T`, hardLimitAttribute))
	}

	instancesAttribute, ok := attributes["instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances is missing from object`)

		return nil, diags
	}

	instancesVal, ok := instancesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances expected to be basetypes.ListValue, was: %T`, instancesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	persistentAttribute, ok := attributes["persistent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persistent is missing from object`)

		return nil, diags
	}

	persistentVal, ok := persistentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persistent expected to be basetypes.BoolValue, was: %T`, persistentAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return nil, diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	softLimitAttribute, ok := attributes["soft_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`soft_limit is missing from object`)

		return nil, diags
	}

	softLimitVal, ok := softLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`soft_limit expected to be basetypes.Int64Value, was: %T`, softLimitAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceGroupsValue{
		Autoscale:  autoscaleVal,
		CreatedAt:  createdAtVal,
		Domains:    domainsVal,
		HardLimit:  hardLimitVal,
		Instances:  instancesVal,
		Name:       nameVal,
		Persistent: persistentVal,
		Services:   servicesVal,
		SoftLimit:  softLimitVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupsValueNull() ServiceGroupsValue {
	return ServiceGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceGroupsValueUnknown() ServiceGroupsValue {
	return ServiceGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceGroupsValue Attribute Value",
				"While creating a ServiceGroupsValue value, a missing attribute value was detected. "+
					"A ServiceGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceGroupsValue Attribute Type",
				"While creating a ServiceGroupsValue value, an invalid attribute value was detected. "+
					"A ServiceGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceGroupsValue Attribute Value",
				"While creating a ServiceGroupsValue value, an extra attribute value was detected. "+
					"A ServiceGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceGroupsValueUnknown(), diags
	}

	autoscaleAttribute, ok := attributes["autoscale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autoscale is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	autoscaleVal, ok := autoscaleAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autoscale expected to be basetypes.BoolValue, was: %T`, autoscaleAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	hardLimitAttribute, ok := attributes["hard_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hard_limit is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	hardLimitVal, ok := hardLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hard_limit expected to be basetypes.Int64Value, was: %T`, hardLimitAttribute))
	}

	instancesAttribute, ok := attributes["instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	instancesVal, ok := instancesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances expected to be basetypes.ListValue, was: %T`, instancesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	persistentAttribute, ok := attributes["persistent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persistent is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	persistentVal, ok := persistentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persistent expected to be basetypes.BoolValue, was: %T`, persistentAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	softLimitAttribute, ok := attributes["soft_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`soft_limit is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	softLimitVal, ok := softLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`soft_limit expected to be basetypes.Int64Value, was: %T`, softLimitAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewServiceGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewServiceGroupsValueUnknown(), diags
	}

	return ServiceGroupsValue{
		Autoscale:  autoscaleVal,
		CreatedAt:  createdAtVal,
		Domains:    domainsVal,
		HardLimit:  hardLimitVal,
		Instances:  instancesVal,
		Name:       nameVal,
		Persistent: persistentVal,
		Services:   servicesVal,
		SoftLimit:  softLimitVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceGroupsValue {
	object, diags := NewServiceGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceGroupsValueMust(ServiceGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceGroupsType) ValueType(ctx context.Context) attr.Value {
	return ServiceGroupsValue{}
}

var _ basetypes.ObjectValuable = ServiceGroupsValue{}

type ServiceGroupsValue struct {
	Autoscale  basetypes.BoolValue   `tfsdk:"autoscale"`
	CreatedAt  basetypes.StringValue `tfsdk:"created_at"`
	Domains    basetypes.ListValue   `tfsdk:"domains"`
	HardLimit  basetypes.Int64Value  `tfsdk:"hard_limit"`
	Instances  basetypes.ListValue   `tfsdk:"instances"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Persistent basetypes.BoolValue   `tfsdk:"persistent"`
	Services   basetypes.ListValue   `tfsdk:"services"`
	SoftLimit  basetypes.Int64Value  `tfsdk:"soft_limit"`
	Uuid       basetypes.StringValue `tfsdk:"uuid"`
	state      attr.ValueState
}

func (v ServiceGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["autoscale"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["domains"] = basetypes.ListType{
		ElemType: DomainsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["hard_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["instances"] = basetypes.ListType{
		ElemType: InstancesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["persistent"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["services"] = basetypes.ListType{
		ElemType: ServicesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["soft_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Autoscale.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autoscale"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Domains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domains"] = val

		val, err = v.HardLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hard_limit"] = val

		val, err = v.Instances.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instances"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Persistent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["persistent"] = val

		val, err = v.Services.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services"] = val

		val, err = v.SoftLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["soft_limit"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceGroupsValue) String() string {
	return "ServiceGroupsValue"
}

func (v ServiceGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	domains := types.ListValueMust(
		DomainsType{
			basetypes.ObjectType{
				AttrTypes: DomainsValue{}.AttributeTypes(ctx),
			},
		},
		v.Domains.Elements(),
	)

	if v.Domains.IsNull() {
		domains = types.ListNull(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Domains.IsUnknown() {
		domains = types.ListUnknown(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	instances := types.ListValueMust(
		InstancesType{
			basetypes.ObjectType{
				AttrTypes: InstancesValue{}.AttributeTypes(ctx),
			},
		},
		v.Instances.Elements(),
	)

	if v.Instances.IsNull() {
		instances = types.ListNull(
			InstancesType{
				basetypes.ObjectType{
					AttrTypes: InstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Instances.IsUnknown() {
		instances = types.ListUnknown(
			InstancesType{
				basetypes.ObjectType{
					AttrTypes: InstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	services := types.ListValueMust(
		ServicesType{
			basetypes.ObjectType{
				AttrTypes: ServicesValue{}.AttributeTypes(ctx),
			},
		},
		v.Services.Elements(),
	)

	if v.Services.IsNull() {
		services = types.ListNull(
			ServicesType{
				basetypes.ObjectType{
					AttrTypes: ServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Services.IsUnknown() {
		services = types.ListUnknown(
			ServicesType{
				basetypes.ObjectType{
					AttrTypes: ServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"autoscale":  basetypes.BoolType{},
		"created_at": basetypes.StringType{},
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"hard_limit": basetypes.Int64Type{},
		"instances": basetypes.ListType{
			ElemType: InstancesValue{}.Type(ctx),
		},
		"name":       basetypes.StringType{},
		"persistent": basetypes.BoolType{},
		"services": basetypes.ListType{
			ElemType: ServicesValue{}.Type(ctx),
		},
		"soft_limit": basetypes.Int64Type{},
		"uuid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autoscale":  v.Autoscale,
			"created_at": v.CreatedAt,
			"domains":    domains,
			"hard_limit": v.HardLimit,
			"instances":  instances,
			"name":       v.Name,
			"persistent": v.Persistent,
			"services":   services,
			"soft_limit": v.SoftLimit,
			"uuid":       v.Uuid,
		})

	return objVal, diags
}

func (v ServiceGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Autoscale.Equal(other.Autoscale) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Domains.Equal(other.Domains) {
		return false
	}

	if !v.HardLimit.Equal(other.HardLimit) {
		return false
	}

	if !v.Instances.Equal(other.Instances) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Persistent.Equal(other.Persistent) {
		return false
	}

	if !v.Services.Equal(other.Services) {
		return false
	}

	if !v.SoftLimit.Equal(other.SoftLimit) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ServiceGroupsValue) Type(ctx context.Context) attr.Type {
	return ServiceGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autoscale":  basetypes.BoolType{},
		"created_at": basetypes.StringType{},
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"hard_limit": basetypes.Int64Type{},
		"instances": basetypes.ListType{
			ElemType: InstancesValue{}.Type(ctx),
		},
		"name":       basetypes.StringType{},
		"persistent": basetypes.BoolType{},
		"services": basetypes.ListType{
			ElemType: ServicesValue{}.Type(ctx),
		},
		"soft_limit": basetypes.Int64Type{},
		"uuid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DomainsType{}

type DomainsType struct {
	basetypes.ObjectType
}

func (t DomainsType) Equal(o attr.Type) bool {
	other, ok := o.(DomainsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DomainsType) String() string {
	return "DomainsType"
}

func (t DomainsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return nil, diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	fqdnAttribute, ok := attributes["fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fqdn is missing from object`)

		return nil, diags
	}

	fqdnVal, ok := fqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fqdn expected to be basetypes.StringValue, was: %T`, fqdnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Fqdn:        fqdnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueNull() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateNull,
	}
}

func NewDomainsValueUnknown() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDomainsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DomainsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DomainsValue Attribute Value",
				"While creating a DomainsValue value, a missing attribute value was detected. "+
					"A DomainsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DomainsValue Attribute Type",
				"While creating a DomainsValue value, an invalid attribute value was detected. "+
					"A DomainsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DomainsValue Attribute Value",
				"While creating a DomainsValue value, an extra attribute value was detected. "+
					"A DomainsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DomainsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	fqdnAttribute, ok := attributes["fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fqdn is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	fqdnVal, ok := fqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fqdn expected to be basetypes.StringValue, was: %T`, fqdnAttribute))
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Fqdn:        fqdnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DomainsValue {
	object, diags := NewDomainsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDomainsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DomainsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDomainsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDomainsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDomainsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDomainsValueMust(DomainsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DomainsType) ValueType(ctx context.Context) attr.Value {
	return DomainsValue{}
}

var _ basetypes.ObjectValuable = DomainsValue{}

type DomainsValue struct {
	Certificate basetypes.ObjectValue `tfsdk:"certificate"`
	Fqdn        basetypes.StringValue `tfsdk:"fqdn"`
	state       attr.ValueState
}

func (v DomainsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["certificate"] = basetypes.ObjectType{
		AttrTypes: CertificateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["fqdn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Certificate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certificate"] = val

		val, err = v.Fqdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fqdn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DomainsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DomainsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DomainsValue) String() string {
	return "DomainsValue"
}

func (v DomainsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var certificate basetypes.ObjectValue

	if v.Certificate.IsNull() {
		certificate = types.ObjectNull(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Certificate.IsUnknown() {
		certificate = types.ObjectUnknown(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Certificate.IsNull() && !v.Certificate.IsUnknown() {
		certificate = types.ObjectValueMust(
			CertificateValue{}.AttributeTypes(ctx),
			v.Certificate.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"fqdn": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certificate": certificate,
			"fqdn":        v.Fqdn,
		})

	return objVal, diags
}

func (v DomainsValue) Equal(o attr.Value) bool {
	other, ok := o.(DomainsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Certificate.Equal(other.Certificate) {
		return false
	}

	if !v.Fqdn.Equal(other.Fqdn) {
		return false
	}

	return true
}

func (v DomainsValue) Type(ctx context.Context) attr.Type {
	return DomainsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DomainsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"fqdn": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CertificateType{}

type CertificateType struct {
	basetypes.ObjectType
}

func (t CertificateType) Equal(o attr.Type) bool {
	other, ok := o.(CertificateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CertificateType) String() string {
	return "CertificateType"
}

func (t CertificateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commonNameAttribute, ok := attributes["common_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`common_name is missing from object`)

		return nil, diags
	}

	commonNameVal, ok := commonNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`common_name expected to be basetypes.StringValue, was: %T`, commonNameAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CertificateValue{
		CommonName: commonNameVal,
		CreatedAt:  createdAtVal,
		Name:       nameVal,
		State:      stateVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueNull() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateNull,
	}
}

func NewCertificateValueUnknown() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCertificateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CertificateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CertificateValue Attribute Value",
				"While creating a CertificateValue value, a missing attribute value was detected. "+
					"A CertificateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CertificateValue Attribute Type",
				"While creating a CertificateValue value, an invalid attribute value was detected. "+
					"A CertificateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CertificateValue Attribute Value",
				"While creating a CertificateValue value, an extra attribute value was detected. "+
					"A CertificateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CertificateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	commonNameAttribute, ok := attributes["common_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`common_name is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	commonNameVal, ok := commonNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`common_name expected to be basetypes.StringValue, was: %T`, commonNameAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	return CertificateValue{
		CommonName: commonNameVal,
		CreatedAt:  createdAtVal,
		Name:       nameVal,
		State:      stateVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CertificateValue {
	object, diags := NewCertificateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCertificateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CertificateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCertificateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCertificateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCertificateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCertificateValueMust(CertificateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CertificateType) ValueType(ctx context.Context) attr.Value {
	return CertificateValue{}
}

var _ basetypes.ObjectValuable = CertificateValue{}

type CertificateValue struct {
	CommonName basetypes.StringValue `tfsdk:"common_name"`
	CreatedAt  basetypes.StringValue `tfsdk:"created_at"`
	Name       basetypes.StringValue `tfsdk:"name"`
	State      basetypes.StringValue `tfsdk:"state"`
	Uuid       basetypes.StringValue `tfsdk:"uuid"`
	state      attr.ValueState
}

func (v CertificateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["common_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CommonName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["common_name"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CertificateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CertificateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CertificateValue) String() string {
	return "CertificateValue"
}

func (v CertificateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"common_name": basetypes.StringType{},
		"created_at":  basetypes.StringType{},
		"name":        basetypes.StringType{},
		"state":       basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"common_name": v.CommonName,
			"created_at":  v.CreatedAt,
			"name":        v.Name,
			"state":       v.State,
			"uuid":        v.Uuid,
		})

	return objVal, diags
}

func (v CertificateValue) Equal(o attr.Value) bool {
	other, ok := o.(CertificateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommonName.Equal(other.CommonName) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v CertificateValue) Type(ctx context.Context) attr.Type {
	return CertificateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CertificateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"common_name": basetypes.StringType{},
		"created_at":  basetypes.StringType{},
		"name":        basetypes.StringType{},
		"state":       basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InstancesType{}

type InstancesType struct {
	basetypes.ObjectType
}

func (t InstancesType) Equal(o attr.Type) bool {
	other, ok := o.(InstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstancesType) String() string {
	return "InstancesType"
}

func (t InstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstancesValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewInstancesValueNull() InstancesValue {
	return InstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewInstancesValueUnknown() InstancesValue {
	return InstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstancesValue Attribute Value",
				"While creating a InstancesValue value, a missing attribute value was detected. "+
					"A InstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstancesValue Attribute Type",
				"While creating a InstancesValue value, an invalid attribute value was detected. "+
					"A InstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstancesValue Attribute Value",
				"While creating a InstancesValue value, an extra attribute value was detected. "+
					"A InstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstancesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewInstancesValueUnknown(), diags
	}

	return InstancesValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstancesValue {
	object, diags := NewInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstancesValueMust(InstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstancesType) ValueType(ctx context.Context) attr.Value {
	return InstancesValue{}
}

var _ basetypes.ObjectValuable = InstancesValue{}

type InstancesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v InstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstancesValue) String() string {
	return "InstancesValue"
}

func (v InstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v InstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(InstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v InstancesValue) Type(ctx context.Context) attr.Type {
	return InstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServicesType{}

type ServicesType struct {
	basetypes.ObjectType
}

func (t ServicesType) Equal(o attr.Type) bool {
	other, ok := o.(ServicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServicesType) String() string {
	return "ServicesType"
}

func (t ServicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	destinationPortAttribute, ok := attributes["destination_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port is missing from object`)

		return nil, diags
	}

	destinationPortVal, ok := destinationPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port expected to be basetypes.Int64Value, was: %T`, destinationPortAttribute))
	}

	handlersAttribute, ok := attributes["handlers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`handlers is missing from object`)

		return nil, diags
	}

	handlersVal, ok := handlersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`handlers expected to be basetypes.ListValue, was: %T`, handlersAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServicesValue{
		DestinationPort: destinationPortVal,
		Handlers:        handlersVal,
		Port:            portVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewServicesValueNull() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateNull,
	}
}

func NewServicesValueUnknown() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServicesValue Attribute Value",
				"While creating a ServicesValue value, a missing attribute value was detected. "+
					"A ServicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServicesValue Attribute Type",
				"While creating a ServicesValue value, an invalid attribute value was detected. "+
					"A ServicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServicesValue Attribute Value",
				"While creating a ServicesValue value, an extra attribute value was detected. "+
					"A ServicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	destinationPortAttribute, ok := attributes["destination_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	destinationPortVal, ok := destinationPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port expected to be basetypes.Int64Value, was: %T`, destinationPortAttribute))
	}

	handlersAttribute, ok := attributes["handlers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`handlers is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	handlersVal, ok := handlersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`handlers expected to be basetypes.ListValue, was: %T`, handlersAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	return ServicesValue{
		DestinationPort: destinationPortVal,
		Handlers:        handlersVal,
		Port:            portVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewServicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServicesValue {
	object, diags := NewServicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServicesValueMust(ServicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServicesType) ValueType(ctx context.Context) attr.Value {
	return ServicesValue{}
}

var _ basetypes.ObjectValuable = ServicesValue{}

type ServicesValue struct {
	DestinationPort basetypes.Int64Value `tfsdk:"destination_port"`
	Handlers        basetypes.ListValue  `tfsdk:"handlers"`
	Port            basetypes.Int64Value `tfsdk:"port"`
	state           attr.ValueState
}

func (v ServicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["destination_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["handlers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DestinationPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port"] = val

		val, err = v.Handlers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["handlers"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServicesValue) String() string {
	return "ServicesValue"
}

func (v ServicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var handlersVal basetypes.ListValue
	switch {
	case v.Handlers.IsUnknown():
		handlersVal = types.ListUnknown(types.StringType)
	case v.Handlers.IsNull():
		handlersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		handlersVal, d = types.ListValue(types.StringType, v.Handlers.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"destination_port": basetypes.Int64Type{},
			"handlers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"port": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"destination_port": basetypes.Int64Type{},
		"handlers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"port": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"destination_port": v.DestinationPort,
			"handlers":         handlersVal,
			"port":             v.Port,
		})

	return objVal, diags
}

func (v ServicesValue) Equal(o attr.Value) bool {
	other, ok := o.(ServicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DestinationPort.Equal(other.DestinationPort) {
		return false
	}

	if !v.Handlers.Equal(other.Handlers) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v ServicesValue) Type(ctx context.Context) attr.Type {
	return ServicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"destination_port": basetypes.Int64Type{},
		"handlers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"port": basetypes.Int64Type{},
	}
}
