// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_unikraft_certificate

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func UnikraftCertificateDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"certificates": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"common_name": schema.StringAttribute{
									Computed: true,
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The time the certificate was created.",
									MarkdownDescription: "The time the certificate was created.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of the certificate.\n\nThis is a human-readable name that can be used to identify the certificate.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the certificate in API calls.",
									MarkdownDescription: "The name of the certificate.\n\nThis is a human-readable name that can be used to identify the certificate.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the certificate in API calls.",
								},
								"state": schema.StringAttribute{
									Computed: true,
								},
								"uuid": schema.StringAttribute{
									Computed:            true,
									Description:         "The UUID of the certificate.\n\nThis is a unique identifier for the certificate that is generated when the\ncertificate is created.  The UUID is used to reference the certificate in\nAPI calls and can be used to identify the certificate in all API calls that\nrequire an identifier.",
									MarkdownDescription: "The UUID of the certificate.\n\nThis is a unique identifier for the certificate that is generated when the\ncertificate is created.  The UUID is used to reference the certificate in\nAPI calls and can be used to identify the certificate in all API calls that\nrequire an identifier.",
								},
							},
							CustomType: CertificatesType{
								ObjectType: types.ObjectType{
									AttrTypes: CertificatesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "The certificate(s) which were retrieved by the request.",
						MarkdownDescription: "The certificate(s) which were retrieved by the request.",
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "The response data for this request.",
				MarkdownDescription: "The response data for this request.",
			},
			"details": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to include details about the certificate in the response.  By\ndefault this is set to true, meaning that all information about the\ncertificate will be included in the response.  If set to false, only the\nbasic information about the certificate will be included, such as its name\nand UUID.",
				MarkdownDescription: "Whether to include details about the certificate in the response.  By\ndefault this is set to true, meaning that all information about the\ncertificate will be included in the response.  If set to false, only the\nbasic information about the certificate will be included, such as its name\nand UUID.",
			},
			"message": schema.StringAttribute{
				Computed:            true,
				Description:         "An optional message providing additional information about the response.",
				MarkdownDescription: "An optional message providing additional information about the response.",
			},
			"op_time_us": schema.Int64Attribute{
				Computed:            true,
				Description:         "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
				MarkdownDescription: "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "The status of the response.",
				MarkdownDescription: "The status of the response.",
			},
		},
	}
}

type UnikraftCertificateModel struct {
	Data     DataValue    `tfsdk:"data"`
	Details  types.Bool   `tfsdk:"details"`
	Message  types.String `tfsdk:"message"`
	OpTimeUs types.Int64  `tfsdk:"op_time_us"`
	Status   types.String `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificatesAttribute, ok := attributes["certificates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificates is missing from object`)

		return nil, diags
	}

	certificatesVal, ok := certificatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificates expected to be basetypes.ListValue, was: %T`, certificatesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Certificates: certificatesVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	certificatesAttribute, ok := attributes["certificates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificates is missing from object`)

		return NewDataValueUnknown(), diags
	}

	certificatesVal, ok := certificatesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificates expected to be basetypes.ListValue, was: %T`, certificatesAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Certificates: certificatesVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Certificates basetypes.ListValue `tfsdk:"certificates"`
	state        attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["certificates"] = basetypes.ListType{
		ElemType: CertificatesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Certificates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certificates"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	certificates := types.ListValueMust(
		CertificatesType{
			basetypes.ObjectType{
				AttrTypes: CertificatesValue{}.AttributeTypes(ctx),
			},
		},
		v.Certificates.Elements(),
	)

	if v.Certificates.IsNull() {
		certificates = types.ListNull(
			CertificatesType{
				basetypes.ObjectType{
					AttrTypes: CertificatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Certificates.IsUnknown() {
		certificates = types.ListUnknown(
			CertificatesType{
				basetypes.ObjectType{
					AttrTypes: CertificatesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"certificates": basetypes.ListType{
			ElemType: CertificatesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certificates": certificates,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Certificates.Equal(other.Certificates) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certificates": basetypes.ListType{
			ElemType: CertificatesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = CertificatesType{}

type CertificatesType struct {
	basetypes.ObjectType
}

func (t CertificatesType) Equal(o attr.Type) bool {
	other, ok := o.(CertificatesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CertificatesType) String() string {
	return "CertificatesType"
}

func (t CertificatesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	commonNameAttribute, ok := attributes["common_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`common_name is missing from object`)

		return nil, diags
	}

	commonNameVal, ok := commonNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`common_name expected to be basetypes.StringValue, was: %T`, commonNameAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CertificatesValue{
		CommonName: commonNameVal,
		CreatedAt:  createdAtVal,
		Name:       nameVal,
		State:      stateVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCertificatesValueNull() CertificatesValue {
	return CertificatesValue{
		state: attr.ValueStateNull,
	}
}

func NewCertificatesValueUnknown() CertificatesValue {
	return CertificatesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCertificatesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CertificatesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CertificatesValue Attribute Value",
				"While creating a CertificatesValue value, a missing attribute value was detected. "+
					"A CertificatesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificatesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CertificatesValue Attribute Type",
				"While creating a CertificatesValue value, an invalid attribute value was detected. "+
					"A CertificatesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificatesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CertificatesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CertificatesValue Attribute Value",
				"While creating a CertificatesValue value, an extra attribute value was detected. "+
					"A CertificatesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CertificatesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCertificatesValueUnknown(), diags
	}

	commonNameAttribute, ok := attributes["common_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`common_name is missing from object`)

		return NewCertificatesValueUnknown(), diags
	}

	commonNameVal, ok := commonNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`common_name expected to be basetypes.StringValue, was: %T`, commonNameAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewCertificatesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCertificatesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewCertificatesValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewCertificatesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewCertificatesValueUnknown(), diags
	}

	return CertificatesValue{
		CommonName: commonNameVal,
		CreatedAt:  createdAtVal,
		Name:       nameVal,
		State:      stateVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCertificatesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CertificatesValue {
	object, diags := NewCertificatesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCertificatesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CertificatesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCertificatesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCertificatesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCertificatesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCertificatesValueMust(CertificatesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CertificatesType) ValueType(ctx context.Context) attr.Value {
	return CertificatesValue{}
}

var _ basetypes.ObjectValuable = CertificatesValue{}

type CertificatesValue struct {
	CommonName basetypes.StringValue `tfsdk:"common_name"`
	CreatedAt  basetypes.StringValue `tfsdk:"created_at"`
	Name       basetypes.StringValue `tfsdk:"name"`
	State      basetypes.StringValue `tfsdk:"state"`
	Uuid       basetypes.StringValue `tfsdk:"uuid"`
	state      attr.ValueState
}

func (v CertificatesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["common_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CommonName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["common_name"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CertificatesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CertificatesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CertificatesValue) String() string {
	return "CertificatesValue"
}

func (v CertificatesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"common_name": basetypes.StringType{},
		"created_at":  basetypes.StringType{},
		"name":        basetypes.StringType{},
		"state":       basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"common_name": v.CommonName,
			"created_at":  v.CreatedAt,
			"name":        v.Name,
			"state":       v.State,
			"uuid":        v.Uuid,
		})

	return objVal, diags
}

func (v CertificatesValue) Equal(o attr.Value) bool {
	other, ok := o.(CertificatesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommonName.Equal(other.CommonName) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v CertificatesValue) Type(ctx context.Context) attr.Type {
	return CertificatesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CertificatesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"common_name": basetypes.StringType{},
		"created_at":  basetypes.StringType{},
		"name":        basetypes.StringType{},
		"state":       basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}
}
