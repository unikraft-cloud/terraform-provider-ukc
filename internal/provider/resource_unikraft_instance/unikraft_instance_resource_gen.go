// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_unikraft_instance

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func UnikraftInstanceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"args": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  The arguments to pass to the instance when it starts.",
				MarkdownDescription: "(Optional).  The arguments to pass to the instance when it starts.",
			},
			"autostart": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether the instance should start automatically on creation.",
				MarkdownDescription: "Whether the instance should start automatically on creation.",
			},
			"details": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to include details about the instance in the response.  By default\nthis is set to true, meaning that all information about the instance will\nbe included in the response.  If set to false, only the basic information\nabout the instance will be included, such as its name and UUID.",
				MarkdownDescription: "Whether to include details about the instance in the response.  By default\nthis is set to true, meaning that all information about the instance will\nbe included in the response.  If set to false, only the basic information\nabout the instance will be included, such as its name and UUID.",
			},
			"env": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  Environment variables to set for the instance.",
				MarkdownDescription: "(Optional).  Environment variables to set for the instance.",
			},
			"features": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Features to enable for the instance.  Features are specific\nconfigurations or capabilities that can be enabled for the instance.",
				MarkdownDescription: "Features to enable for the instance.  Features are specific\nconfigurations or capabilities that can be enabled for the instance.",
			},
			"image": schema.StringAttribute{
				Required:            true,
				Description:         "The image to use for the instance.",
				MarkdownDescription: "The image to use for the instance.",
			},
			"memory_mb": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  Memory in MB to allocate for the instance.  Default is 128.",
				MarkdownDescription: "(Optional).  Memory in MB to allocate for the instance.  Default is 128.",
			},
			"metrics": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to include metrics about the instance in the response.  By default\nthis is set to false, meaning that no metrics will be included in the\nresponse.",
				MarkdownDescription: "Whether to include metrics about the instance in the response.  By default\nthis is set to false, meaning that no metrics will be included in the\nresponse.",
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  The name of the instance.\n\nIf not provided, a random name will be generated. The name must be unique.",
				MarkdownDescription: "(Optional).  The name of the instance.\n\nIf not provided, a random name will be generated. The name must be unique.",
			},
			"replicas": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of replicas for the instance.",
				MarkdownDescription: "Number of replicas for the instance.",
			},
			"restart_policy": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Restart policy for the instance.  This defines how the instance should\nbehave when it stops or crashes.",
				MarkdownDescription: "Restart policy for the instance.  This defines how the instance should\nbehave when it stops or crashes.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"never",
						"always",
						"on_failure",
					),
				},
			},
			"scale_to_zero": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cooldown_time_ms": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The cooldown time in milliseconds before the instance can be scaled to\nzero again.  This is useful to prevent rapid scaling to zero and back up,\nwhich can lead to performance issues or resource exhaustion.",
						MarkdownDescription: "The cooldown time in milliseconds before the instance can be scaled to\nzero again.  This is useful to prevent rapid scaling to zero and back up,\nwhich can lead to performance issues or resource exhaustion.",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates whether scale-to-zero is enabled for the instance.",
						MarkdownDescription: "Indicates whether scale-to-zero is enabled for the instance.",
					},
					"policy": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The specific policy to use for scaling the instance to zero.",
						MarkdownDescription: "The specific policy to use for scaling the instance to zero.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"on",
								"off",
								"idle",
							),
						},
					},
					"stateful": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether the instance should be stateful when scaled to zero. If set to\ntrue, the instance will retain its state (e.g., RAM contents) when scaled\nto zero.  This is useful for instances that need to maintain their state\nacross scale-to-zero operations.  If set to false, the instance will lose\nits state when scaled to zero, and it will be restarted from scratch when\nscaled back up.",
						MarkdownDescription: "Whether the instance should be stateful when scaled to zero. If set to\ntrue, the instance will retain its state (e.g., RAM contents) when scaled\nto zero.  This is useful for instances that need to maintain their state\nacross scale-to-zero operations.  If set to false, the instance will lose\nits state when scaled to zero, and it will be restarted from scratch when\nscaled back up.",
					},
				},
				CustomType: ScaleToZeroType{
					ObjectType: types.ObjectType{
						AttrTypes: ScaleToZeroValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Scale-to-zero configuration for the instance.",
				MarkdownDescription: "Scale-to-zero configuration for the instance.",
			},
			"service_group": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"domains": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"certificate": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "(Optional).  The name of the existing certificate. Mutually exclusive with UUID.",
											MarkdownDescription: "(Optional).  The name of the existing certificate. Mutually exclusive with UUID.",
										},
										"uuid": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "(Optional).  The UUID for the existing certificate. Mutually exclusive with name.",
											MarkdownDescription: "(Optional).  The UUID for the existing certificate. Mutually exclusive with name.",
										},
									},
									CustomType: CertificateType{
										ObjectType: types.ObjectType{
											AttrTypes: CertificateValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "A reference to an existing certificate which can be used for the specified domain.  If unspecified, Unikraft Cloud will automatically generate a new certificate for the domain based on Let's Encrypt and seek to accomplish a DNS-01 challenge.",
									MarkdownDescription: "A reference to an existing certificate which can be used for the specified domain.  If unspecified, Unikraft Cloud will automatically generate a new certificate for the domain based on Let's Encrypt and seek to accomplish a DNS-01 challenge.",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "Publicly accessible domain name.\n\nIf this name ends in a period `.` it must be a valid Full Qualified\nDomain Name (FQDN), e.g. `example.com.`; otherwise it will become\nsubdomain of the target metro, e.g. `example` becomes `example.fra0.unikraft.app`.",
									MarkdownDescription: "Publicly accessible domain name.\n\nIf this name ends in a period `.` it must be a valid Full Qualified\nDomain Name (FQDN), e.g. `example.com.`; otherwise it will become\nsubdomain of the target metro, e.g. `example` becomes `example.fra0.unikraft.app`.",
								},
							},
							CustomType: DomainsType{
								ObjectType: types.ObjectType{
									AttrTypes: DomainsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Similarly, if no existing (persistent) service group is specified via its identifier, a new (ephemeral) service group can be created.  In addition to the services it must expose, you can specify which domains it should use too.",
						MarkdownDescription: "Similarly, if no existing (persistent) service group is specified via its identifier, a new (ephemeral) service group can be created.  In addition to the services it must expose, you can specify which domains it should use too.",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "(Optional).  Reference an existing (persistent) service group by its name. Mutually exclusive with UUID.",
						MarkdownDescription: "(Optional).  Reference an existing (persistent) service group by its name. Mutually exclusive with UUID.",
					},
					"uuid": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "(Optional).  Reference an existing (persistent) service group by its UUID. Mutually exclusive with name.",
						MarkdownDescription: "(Optional).  Reference an existing (persistent) service group by its UUID. Mutually exclusive with name.",
					},
				},
				CustomType: ServiceGroupType{
					ObjectType: types.ObjectType{
						AttrTypes: ServiceGroupValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  The service group configuration when creating an instance.\n\nWhen creating an instance, either a previously created (persistent) service\ngroup can be referenced (either through its name or UUID), or a new\n(ephemeral) service group can be created for the instance by specifying the\nlist of services it should expose and optionally the domains it should use.",
				MarkdownDescription: "(Optional).  The service group configuration when creating an instance.\n\nWhen creating an instance, either a previously created (persistent) service\ngroup can be referenced (either through its name or UUID), or a new\n(ephemeral) service group can be created for the instance by specifying the\nlist of services it should expose and optionally the domains it should use.",
			},
			"uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The UUID of the instance to get.",
				MarkdownDescription: "The UUID of the instance to get.",
			},
			"vcpus": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of vCPUs to allocate for the instance.",
				MarkdownDescription: "Number of vCPUs to allocate for the instance.",
			},
			"volumes": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"at": schema.StringAttribute{
							Required:            true,
							Description:         "The mount point for the volume in the instance.",
							MarkdownDescription: "The mount point for the volume in the instance.",
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The name of the volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this name.  If the volume does not exist, the request will\nfail.  If a new volume is intended to be created, then this field must be\nspecified along with the size in MiB and the mount point in the instance.",
							MarkdownDescription: "The name of the volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this name.  If the volume does not exist, the request will\nfail.  If a new volume is intended to be created, then this field must be\nspecified along with the size in MiB and the mount point in the instance.",
						},
						"read_only": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Whether the volume is read-only.\n\nIf this field is set to true, the volume will be mounted as read-only in\nthe instance.  This field is optional and defaults to false and is only\napplicable when using an existing volume.",
							MarkdownDescription: "Whether the volume is read-only.\n\nIf this field is set to true, the volume will be mounted as read-only in\nthe instance.  This field is optional and defaults to false and is only\napplicable when using an existing volume.",
						},
						"size_mb": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "The size of the volume when creating a new volume.\n\nWhen creating a new volume as part of the instance create request,\nspecify the size of the volume in MiB.",
							MarkdownDescription: "The size of the volume when creating a new volume.\n\nWhen creating a new volume as part of the instance create request,\nspecify the size of the volume in MiB.",
						},
						"uuid": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The UUID of an existing volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this UUID.",
							MarkdownDescription: "The UUID of an existing volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this UUID.",
						},
					},
					CustomType: VolumesType{
						ObjectType: types.ObjectType{
							AttrTypes: VolumesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Volumes to attach to the instance.\n\nThis list can contain both existing and new volumes to create as part of\nthe instance creation.  Existing volumes can be referenced by their name or\nUUID.  New volumes can be created by specifying a name, size in MiB, and\nmount point in the instance.  The mount point is the directory in the\ninstance where the volume will be mounted.",
				MarkdownDescription: "Volumes to attach to the instance.\n\nThis list can contain both existing and new volumes to create as part of\nthe instance creation.  Existing volumes can be referenced by their name or\nUUID.  New volumes can be created by specifying a name, size in MiB, and\nmount point in the instance.  The mount point is the directory in the\ninstance where the volume will be mounted.",
			},
			"wait_timeout_ms": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Timeout to wait for all new instances to reach running state in\nmilliseconds.  If you autostart your new instance, you can wait for it to\nfinish starting with a blocking API call if you specify a wait timeout\ngreater than zero.  No wait performed for a value of 0.",
				MarkdownDescription: "Timeout to wait for all new instances to reach running state in\nmilliseconds.  If you autostart your new instance, you can wait for it to\nfinish starting with a blocking API call if you specify a wait timeout\ngreater than zero.  No wait performed for a value of 0.",
			},
		},
	}
}

type UnikraftInstanceModel struct {
	Args          types.List        `tfsdk:"args"`
	Autostart     types.Bool        `tfsdk:"autostart"`
	Details       types.Bool        `tfsdk:"details"`
	Env           types.Map         `tfsdk:"env"`
	Features      types.List        `tfsdk:"features"`
	Image         types.String      `tfsdk:"image"`
	MemoryMb      types.Int64       `tfsdk:"memory_mb"`
	Metrics       types.Bool        `tfsdk:"metrics"`
	Name          types.String      `tfsdk:"name"`
	Replicas      types.Int64       `tfsdk:"replicas"`
	RestartPolicy types.String      `tfsdk:"restart_policy"`
	ScaleToZero   ScaleToZeroValue  `tfsdk:"scale_to_zero"`
	ServiceGroup  ServiceGroupValue `tfsdk:"service_group"`
	Uuid          types.String      `tfsdk:"uuid"`
	Vcpus         types.Int64       `tfsdk:"vcpus"`
	Volumes       types.List        `tfsdk:"volumes"`
	WaitTimeoutMs types.Int64       `tfsdk:"wait_timeout_ms"`
}

var _ basetypes.ObjectTypable = ScaleToZeroType{}

type ScaleToZeroType struct {
	basetypes.ObjectType
}

func (t ScaleToZeroType) Equal(o attr.Type) bool {
	other, ok := o.(ScaleToZeroType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScaleToZeroType) String() string {
	return "ScaleToZeroType"
}

func (t ScaleToZeroType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cooldownTimeMsAttribute, ok := attributes["cooldown_time_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown_time_ms is missing from object`)

		return nil, diags
	}

	cooldownTimeMsVal, ok := cooldownTimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown_time_ms expected to be basetypes.Int64Value, was: %T`, cooldownTimeMsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return nil, diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	statefulAttribute, ok := attributes["stateful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stateful is missing from object`)

		return nil, diags
	}

	statefulVal, ok := statefulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stateful expected to be basetypes.BoolValue, was: %T`, statefulAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScaleToZeroValue{
		CooldownTimeMs: cooldownTimeMsVal,
		Enabled:        enabledVal,
		Policy:         policyVal,
		Stateful:       statefulVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewScaleToZeroValueNull() ScaleToZeroValue {
	return ScaleToZeroValue{
		state: attr.ValueStateNull,
	}
}

func NewScaleToZeroValueUnknown() ScaleToZeroValue {
	return ScaleToZeroValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScaleToZeroValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScaleToZeroValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScaleToZeroValue Attribute Value",
				"While creating a ScaleToZeroValue value, a missing attribute value was detected. "+
					"A ScaleToZeroValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScaleToZeroValue Attribute Type",
				"While creating a ScaleToZeroValue value, an invalid attribute value was detected. "+
					"A ScaleToZeroValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScaleToZeroValue Attribute Value",
				"While creating a ScaleToZeroValue value, an extra attribute value was detected. "+
					"A ScaleToZeroValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScaleToZeroValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScaleToZeroValueUnknown(), diags
	}

	cooldownTimeMsAttribute, ok := attributes["cooldown_time_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown_time_ms is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	cooldownTimeMsVal, ok := cooldownTimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown_time_ms expected to be basetypes.Int64Value, was: %T`, cooldownTimeMsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	statefulAttribute, ok := attributes["stateful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stateful is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	statefulVal, ok := statefulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stateful expected to be basetypes.BoolValue, was: %T`, statefulAttribute))
	}

	if diags.HasError() {
		return NewScaleToZeroValueUnknown(), diags
	}

	return ScaleToZeroValue{
		CooldownTimeMs: cooldownTimeMsVal,
		Enabled:        enabledVal,
		Policy:         policyVal,
		Stateful:       statefulVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewScaleToZeroValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScaleToZeroValue {
	object, diags := NewScaleToZeroValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScaleToZeroValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScaleToZeroType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScaleToZeroValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScaleToZeroValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScaleToZeroValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScaleToZeroValueMust(ScaleToZeroValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScaleToZeroType) ValueType(ctx context.Context) attr.Value {
	return ScaleToZeroValue{}
}

var _ basetypes.ObjectValuable = ScaleToZeroValue{}

type ScaleToZeroValue struct {
	CooldownTimeMs basetypes.Int64Value  `tfsdk:"cooldown_time_ms"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	Policy         basetypes.StringValue `tfsdk:"policy"`
	Stateful       basetypes.BoolValue   `tfsdk:"stateful"`
	state          attr.ValueState
}

func (v ScaleToZeroValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cooldown_time_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stateful"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CooldownTimeMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cooldown_time_ms"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Policy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy"] = val

		val, err = v.Stateful.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stateful"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScaleToZeroValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScaleToZeroValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScaleToZeroValue) String() string {
	return "ScaleToZeroValue"
}

func (v ScaleToZeroValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cooldown_time_ms": basetypes.Int64Type{},
		"enabled":          basetypes.BoolType{},
		"policy":           basetypes.StringType{},
		"stateful":         basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cooldown_time_ms": v.CooldownTimeMs,
			"enabled":          v.Enabled,
			"policy":           v.Policy,
			"stateful":         v.Stateful,
		})

	return objVal, diags
}

func (v ScaleToZeroValue) Equal(o attr.Value) bool {
	other, ok := o.(ScaleToZeroValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CooldownTimeMs.Equal(other.CooldownTimeMs) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Policy.Equal(other.Policy) {
		return false
	}

	if !v.Stateful.Equal(other.Stateful) {
		return false
	}

	return true
}

func (v ScaleToZeroValue) Type(ctx context.Context) attr.Type {
	return ScaleToZeroType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScaleToZeroValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cooldown_time_ms": basetypes.Int64Type{},
		"enabled":          basetypes.BoolType{},
		"policy":           basetypes.StringType{},
		"stateful":         basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServiceGroupType{}

type ServiceGroupType struct {
	basetypes.ObjectType
}

func (t ServiceGroupType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceGroupType) String() string {
	return "ServiceGroupType"
}

func (t ServiceGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return nil, diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceGroupValue{
		Domains: domainsVal,
		Name:    nameVal,
		Uuid:    uuidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupValueNull() ServiceGroupValue {
	return ServiceGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceGroupValueUnknown() ServiceGroupValue {
	return ServiceGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceGroupValue Attribute Value",
				"While creating a ServiceGroupValue value, a missing attribute value was detected. "+
					"A ServiceGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceGroupValue Attribute Type",
				"While creating a ServiceGroupValue value, an invalid attribute value was detected. "+
					"A ServiceGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceGroupValue Attribute Value",
				"While creating a ServiceGroupValue value, an extra attribute value was detected. "+
					"A ServiceGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceGroupValueUnknown(), diags
	}

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewServiceGroupValueUnknown(), diags
	}

	return ServiceGroupValue{
		Domains: domainsVal,
		Name:    nameVal,
		Uuid:    uuidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceGroupValue {
	object, diags := NewServiceGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceGroupValueMust(ServiceGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceGroupType) ValueType(ctx context.Context) attr.Value {
	return ServiceGroupValue{}
}

var _ basetypes.ObjectValuable = ServiceGroupValue{}

type ServiceGroupValue struct {
	Domains basetypes.ListValue   `tfsdk:"domains"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Uuid    basetypes.StringValue `tfsdk:"uuid"`
	state   attr.ValueState
}

func (v ServiceGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["domains"] = basetypes.ListType{
		ElemType: DomainsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Domains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domains"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceGroupValue) String() string {
	return "ServiceGroupValue"
}

func (v ServiceGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	domains := types.ListValueMust(
		DomainsType{
			basetypes.ObjectType{
				AttrTypes: DomainsValue{}.AttributeTypes(ctx),
			},
		},
		v.Domains.Elements(),
	)

	if v.Domains.IsNull() {
		domains = types.ListNull(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Domains.IsUnknown() {
		domains = types.ListUnknown(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"domains": domains,
			"name":    v.Name,
			"uuid":    v.Uuid,
		})

	return objVal, diags
}

func (v ServiceGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Domains.Equal(other.Domains) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ServiceGroupValue) Type(ctx context.Context) attr.Type {
	return ServiceGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DomainsType{}

type DomainsType struct {
	basetypes.ObjectType
}

func (t DomainsType) Equal(o attr.Type) bool {
	other, ok := o.(DomainsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DomainsType) String() string {
	return "DomainsType"
}

func (t DomainsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return nil, diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueNull() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateNull,
	}
}

func NewDomainsValueUnknown() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDomainsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DomainsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DomainsValue Attribute Value",
				"While creating a DomainsValue value, a missing attribute value was detected. "+
					"A DomainsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DomainsValue Attribute Type",
				"While creating a DomainsValue value, an invalid attribute value was detected. "+
					"A DomainsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DomainsValue Attribute Value",
				"While creating a DomainsValue value, an extra attribute value was detected. "+
					"A DomainsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DomainsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DomainsValue {
	object, diags := NewDomainsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDomainsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DomainsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDomainsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDomainsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDomainsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDomainsValueMust(DomainsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DomainsType) ValueType(ctx context.Context) attr.Value {
	return DomainsValue{}
}

var _ basetypes.ObjectValuable = DomainsValue{}

type DomainsValue struct {
	Certificate basetypes.ObjectValue `tfsdk:"certificate"`
	Name        basetypes.StringValue `tfsdk:"name"`
	state       attr.ValueState
}

func (v DomainsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["certificate"] = basetypes.ObjectType{
		AttrTypes: CertificateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Certificate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certificate"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DomainsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DomainsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DomainsValue) String() string {
	return "DomainsValue"
}

func (v DomainsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var certificate basetypes.ObjectValue

	if v.Certificate.IsNull() {
		certificate = types.ObjectNull(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Certificate.IsUnknown() {
		certificate = types.ObjectUnknown(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Certificate.IsNull() && !v.Certificate.IsUnknown() {
		certificate = types.ObjectValueMust(
			CertificateValue{}.AttributeTypes(ctx),
			v.Certificate.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certificate": certificate,
			"name":        v.Name,
		})

	return objVal, diags
}

func (v DomainsValue) Equal(o attr.Value) bool {
	other, ok := o.(DomainsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Certificate.Equal(other.Certificate) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v DomainsValue) Type(ctx context.Context) attr.Type {
	return DomainsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DomainsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CertificateType{}

type CertificateType struct {
	basetypes.ObjectType
}

func (t CertificateType) Equal(o attr.Type) bool {
	other, ok := o.(CertificateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CertificateType) String() string {
	return "CertificateType"
}

func (t CertificateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CertificateValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueNull() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateNull,
	}
}

func NewCertificateValueUnknown() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCertificateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CertificateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CertificateValue Attribute Value",
				"While creating a CertificateValue value, a missing attribute value was detected. "+
					"A CertificateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CertificateValue Attribute Type",
				"While creating a CertificateValue value, an invalid attribute value was detected. "+
					"A CertificateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CertificateValue Attribute Value",
				"While creating a CertificateValue value, an extra attribute value was detected. "+
					"A CertificateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CertificateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	return CertificateValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CertificateValue {
	object, diags := NewCertificateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCertificateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CertificateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCertificateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCertificateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCertificateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCertificateValueMust(CertificateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CertificateType) ValueType(ctx context.Context) attr.Value {
	return CertificateValue{}
}

var _ basetypes.ObjectValuable = CertificateValue{}

type CertificateValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v CertificateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CertificateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CertificateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CertificateValue) String() string {
	return "CertificateValue"
}

func (v CertificateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v CertificateValue) Equal(o attr.Value) bool {
	other, ok := o.(CertificateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v CertificateValue) Type(ctx context.Context) attr.Type {
	return CertificateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CertificateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesType{}

type VolumesType struct {
	basetypes.ObjectType
}

func (t VolumesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesType) String() string {
	return "VolumesType"
}

func (t VolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	atAttribute, ok := attributes["at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`at is missing from object`)

		return nil, diags
	}

	atVal, ok := atAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`at expected to be basetypes.StringValue, was: %T`, atAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return nil, diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	sizeMbAttribute, ok := attributes["size_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_mb is missing from object`)

		return nil, diags
	}

	sizeMbVal, ok := sizeMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_mb expected to be basetypes.Int64Value, was: %T`, sizeMbAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesValue{
		At:       atVal,
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		SizeMb:   sizeMbVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueNull() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesValueUnknown() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesValue Attribute Value",
				"While creating a VolumesValue value, a missing attribute value was detected. "+
					"A VolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesValue Attribute Type",
				"While creating a VolumesValue value, an invalid attribute value was detected. "+
					"A VolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesValue Attribute Value",
				"While creating a VolumesValue value, an extra attribute value was detected. "+
					"A VolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	atAttribute, ok := attributes["at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`at is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	atVal, ok := atAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`at expected to be basetypes.StringValue, was: %T`, atAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	sizeMbAttribute, ok := attributes["size_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_mb is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	sizeMbVal, ok := sizeMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_mb expected to be basetypes.Int64Value, was: %T`, sizeMbAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	return VolumesValue{
		At:       atVal,
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		SizeMb:   sizeMbVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesValue {
	object, diags := NewVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesValueMust(VolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesType) ValueType(ctx context.Context) attr.Value {
	return VolumesValue{}
}

var _ basetypes.ObjectValuable = VolumesValue{}

type VolumesValue struct {
	At       basetypes.StringValue `tfsdk:"at"`
	Name     basetypes.StringValue `tfsdk:"name"`
	ReadOnly basetypes.BoolValue   `tfsdk:"read_only"`
	SizeMb   basetypes.Int64Value  `tfsdk:"size_mb"`
	Uuid     basetypes.StringValue `tfsdk:"uuid"`
	state    attr.ValueState
}

func (v VolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["size_mb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.At.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["at"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ReadOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read_only"] = val

		val, err = v.SizeMb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_mb"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesValue) String() string {
	return "VolumesValue"
}

func (v VolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"at":        basetypes.StringType{},
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"size_mb":   basetypes.Int64Type{},
		"uuid":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"at":        v.At,
			"name":      v.Name,
			"read_only": v.ReadOnly,
			"size_mb":   v.SizeMb,
			"uuid":      v.Uuid,
		})

	return objVal, diags
}

func (v VolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.At.Equal(other.At) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ReadOnly.Equal(other.ReadOnly) {
		return false
	}

	if !v.SizeMb.Equal(other.SizeMb) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v VolumesValue) Type(ctx context.Context) attr.Type {
	return VolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"at":        basetypes.StringType{},
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"size_mb":   basetypes.Int64Type{},
		"uuid":      basetypes.StringType{},
	}
}
