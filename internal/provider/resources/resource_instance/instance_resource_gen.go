// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_instance

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func InstanceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"args": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  The arguments to pass to the instance when it starts.",
				MarkdownDescription: "(Optional).  The arguments to pass to the instance when it starts.",
			},
			"autostart": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether the instance should start automatically on creation.",
				MarkdownDescription: "Whether the instance should start automatically on creation.",
			},
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"instances": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "The arguments passed to the instance when it was started.  This is a\nlist of command-line arguments that were provided to the instance at\nstartup.  These arguments can be used to configure the behavior of the\ninstance and its applications.",
									MarkdownDescription: "The arguments passed to the instance when it was started.  This is a\nlist of command-line arguments that were provided to the instance at\nstartup.  These arguments can be used to configure the behavior of the\ninstance and its applications.",
								},
								"boot_time_us": schema.Int64Attribute{
									Computed:            true,
									Description:         "The boot time of the instance in microseconds.  We take a pragmatic\napproach is to define the boot time.  We calculate this as the difference\nin time between the moment the virtualization toolstack is invoked to\nrespond to a VM boot request and the moment the OS starts executing user\ncode (i.e., the end of the guest OS boot process).  This is essentially the\ntime that a user would experience in a deployment, minus the application\ninitialization time, which we leave out since it is independent from the\nOS.",
									MarkdownDescription: "The boot time of the instance in microseconds.  We take a pragmatic\napproach is to define the boot time.  We calculate this as the difference\nin time between the moment the virtualization toolstack is invoked to\nrespond to a VM boot request and the moment the OS starts executing user\ncode (i.e., the end of the guest OS boot process).  This is essentially the\ntime that a user would experience in a deployment, minus the application\ninitialization time, which we leave out since it is independent from the\nOS.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The time the instance was created.",
									MarkdownDescription: "The time the instance was created.",
								},
								"exit_code": schema.Int64Attribute{
									Computed:            true,
									Description:         "The application exit code.\n\nThis is the code which the application returns upon leaving its main entry\npoint.  The encoding of the exit code is application specific. See the\ndocumentation of the application for more details.  Usually, an exit code\nof `0` indicates success / no failure.",
									MarkdownDescription: "The application exit code.\n\nThis is the code which the application returns upon leaving its main entry\npoint.  The encoding of the exit code is application specific. See the\ndocumentation of the application for more details.  Usually, an exit code\nof `0` indicates success / no failure.",
								},
								"image": schema.StringAttribute{
									Computed:            true,
									Description:         "The image used to create the instance.  This is a reference to the\nUnikraft image that was used to create the instance.",
									MarkdownDescription: "The image used to create the instance.  This is a reference to the\nUnikraft image that was used to create the instance.",
								},
								"memory_mb": schema.Int64Attribute{
									Computed:            true,
									Description:         "The amount of memory in megabytes allocated for the instance.  This is the\ntotal amount of memory that is available to the instance for its\noperations.",
									MarkdownDescription: "The amount of memory in megabytes allocated for the instance.  This is the\ntotal amount of memory that is available to the instance for its\noperations.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of the instance.\n\nThis is a human-readable name that can be used to identify the instance.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the instance in API calls.",
									MarkdownDescription: "The name of the instance.\n\nThis is a human-readable name that can be used to identify the instance.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the instance in API calls.",
								},
								"net_time_us": schema.Int64Attribute{
									Computed:            true,
									Description:         "This is the time it took for the user-level application to start listening\non a non-localhost port measured in microseconds.  This is the time from\nwhen the instance started until it reasonably ready to start responding to\nnetwork requests.  This is useful for measuring the time it takes for the\ninstance to become operationally ready.",
									MarkdownDescription: "This is the time it took for the user-level application to start listening\non a non-localhost port measured in microseconds.  This is the time from\nwhen the instance started until it reasonably ready to start responding to\nnetwork requests.  This is useful for measuring the time it takes for the\ninstance to become operationally ready.",
								},
								"network_interfaces": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"mac": schema.StringAttribute{
												Computed:            true,
												Description:         "The MAC address of the network interface.",
												MarkdownDescription: "The MAC address of the network interface.",
											},
											"private_ip": schema.StringAttribute{
												Computed:            true,
												Description:         "The private IP address of the network interface. This is the internal IP\naddress that is used for communication between instances within the same\nnetwork.",
												MarkdownDescription: "The private IP address of the network interface. This is the internal IP\naddress that is used for communication between instances within the same\nnetwork.",
											},
											"rx_bytes": schema.Int64Attribute{
												Computed:            true,
												Description:         "Amount of bytes received from interface.",
												MarkdownDescription: "Amount of bytes received from interface.",
											},
											"rx_packets": schema.Int64Attribute{
												Computed:            true,
												Description:         "Count of packets received from interface",
												MarkdownDescription: "Count of packets received from interface",
											},
											"tx_bytes": schema.Int64Attribute{
												Computed:            true,
												Description:         "Amount of bytes sent to interface.",
												MarkdownDescription: "Amount of bytes sent to interface.",
											},
											"tx_packets": schema.Int64Attribute{
												Computed:            true,
												Description:         "Count of packets sent to interface",
												MarkdownDescription: "Count of packets sent to interface",
											},
											"uuid": schema.StringAttribute{
												Computed:            true,
												Description:         "The UUID of the network interface. This is a unique identifier for the\nnetwork interface that is generated when the instance is created.",
												MarkdownDescription: "The UUID of the network interface. This is a unique identifier for the\nnetwork interface that is generated when the instance is created.",
											},
										},
										CustomType: NetworkInterfacesType{
											ObjectType: types.ObjectType{
												AttrTypes: NetworkInterfacesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "The network interfaces of the instance.",
									MarkdownDescription: "The network interfaces of the instance.",
								},
								"private_fqdn": schema.StringAttribute{
									Computed:            true,
									Description:         "The internal hostname of the instance.  This address can be used privately\nwithin the Unikraft Cloud network to access the instance.  It is not\naccessible from the public Internet.",
									MarkdownDescription: "The internal hostname of the instance.  This address can be used privately\nwithin the Unikraft Cloud network to access the instance.  It is not\naccessible from the public Internet.",
								},
								"restart_policy": schema.StringAttribute{
									Computed:            true,
									Description:         "The restart configuration for the instance.\n\nWhen an instance stops either because the application exits or the instance\ncrashes, Unikraft Cloud can auto-restart your instance.  Auto-restarts are\nperformed according to the restart policy configured for a particular\ninstance.\n\nThe policy can have the following values:\n\n| Policy       | Description |\n|--------------|-------------|\n| `never`      | Never restart the instance (default). |\n| `always`     | Always restart the instance when the stop is initiated from within the instance (i.e., the application exits or the instance crashes). |\n| `on-failure` | Only restart the instance if it crashes. |\n\nWhen an instance stops, the stop reason and the configured restart policy\nare evaluated to decide if a restart should be performed.  Unikraft Cloud\nuses an exponential back-off delay (immediate, 5s, 10s, 20s, 40s, ..., 5m)\nto slow down restarts in tight crash loops. If an instance runs without\nproblems for 10s the back-off delay is reset and the restart sequence ends.\n\nThe `restart.attempt` attribute reported in counts the number of restarts\nperformed in the current sequence.  The `restart.next_at` field indicates\nwhen the next restart will take place if a back-off delay is in effect.\n\nA manual start or stop of the instance aborts the restart sequence and\nresets the back-off delay.",
									MarkdownDescription: "The restart configuration for the instance.\n\nWhen an instance stops either because the application exits or the instance\ncrashes, Unikraft Cloud can auto-restart your instance.  Auto-restarts are\nperformed according to the restart policy configured for a particular\ninstance.\n\nThe policy can have the following values:\n\n| Policy       | Description |\n|--------------|-------------|\n| `never`      | Never restart the instance (default). |\n| `always`     | Always restart the instance when the stop is initiated from within the instance (i.e., the application exits or the instance crashes). |\n| `on-failure` | Only restart the instance if it crashes. |\n\nWhen an instance stops, the stop reason and the configured restart policy\nare evaluated to decide if a restart should be performed.  Unikraft Cloud\nuses an exponential back-off delay (immediate, 5s, 10s, 20s, 40s, ..., 5m)\nto slow down restarts in tight crash loops. If an instance runs without\nproblems for 10s the back-off delay is reset and the restart sequence ends.\n\nThe `restart.attempt` attribute reported in counts the number of restarts\nperformed in the current sequence.  The `restart.next_at` field indicates\nwhen the next restart will take place if a back-off delay is in effect.\n\nA manual start or stop of the instance aborts the restart sequence and\nresets the back-off delay.",
								},
								"scale_to_zero": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"cooldown_time_ms": schema.Int64Attribute{
											Computed:            true,
											Description:         "The cooldown time in milliseconds before the instance can be scaled to\nzero again.  This is useful to prevent rapid scaling to zero and back up,\nwhich can lead to performance issues or resource exhaustion.",
											MarkdownDescription: "The cooldown time in milliseconds before the instance can be scaled to\nzero again.  This is useful to prevent rapid scaling to zero and back up,\nwhich can lead to performance issues or resource exhaustion.",
										},
										"enabled": schema.BoolAttribute{
											Computed:            true,
											Description:         "Indicates whether scale-to-zero is enabled for the instance.",
											MarkdownDescription: "Indicates whether scale-to-zero is enabled for the instance.",
										},
										"policy": schema.StringAttribute{
											Computed:            true,
											Description:         "The specific policy to use for scaling the instance to zero.",
											MarkdownDescription: "The specific policy to use for scaling the instance to zero.",
										},
										"stateful": schema.BoolAttribute{
											Computed:            true,
											Description:         "Whether the instance should be stateful when scaled to zero. If set to\ntrue, the instance will retain its state (e.g., RAM contents) when scaled\nto zero.  This is useful for instances that need to maintain their state\nacross scale-to-zero operations.  If set to false, the instance will lose\nits state when scaled to zero, and it will be restarted from scratch when\nscaled back up.",
											MarkdownDescription: "Whether the instance should be stateful when scaled to zero. If set to\ntrue, the instance will retain its state (e.g., RAM contents) when scaled\nto zero.  This is useful for instances that need to maintain their state\nacross scale-to-zero operations.  If set to false, the instance will lose\nits state when scaled to zero, and it will be restarted from scratch when\nscaled back up.",
										},
									},
									CustomType: ScaleToZeroType{
										ObjectType: types.ObjectType{
											AttrTypes: ScaleToZeroValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "The scale-to-zero configuration for the instance.\n\nWith conventional cloud platforms you need to keep at least one instance\nrunning at all times to be able to respond to incoming requests. Performing\na just-in-time cold boot is simply too time-consuming and would create a\nresponse latency of multiple seconds.  This is not the case with Unikraft\nCloud.  Instances on Unikraft Cloud are able to cold boot within\nmilliseconds, which allows us to perform low-latency scale-to-zero.\n\nTo enable scale-to-zero for an instance it is sufficient to add a\n`scale_to_zero` configuration block.  Unikraft Cloud will then put the\ninstance into standby if there is no traffic to your service within the\nwindow of a cooldown period. When there is new traffic coming in, it is\nautomatically started again.\n\nIf you have a heavyweight application that takes long to cold boot or has\nbad first request latency (e.g., with JIT compilation) consider to enable\nstateful scale-to-zero.",
									MarkdownDescription: "The scale-to-zero configuration for the instance.\n\nWith conventional cloud platforms you need to keep at least one instance\nrunning at all times to be able to respond to incoming requests. Performing\na just-in-time cold boot is simply too time-consuming and would create a\nresponse latency of multiple seconds.  This is not the case with Unikraft\nCloud.  Instances on Unikraft Cloud are able to cold boot within\nmilliseconds, which allows us to perform low-latency scale-to-zero.\n\nTo enable scale-to-zero for an instance it is sufficient to add a\n`scale_to_zero` configuration block.  Unikraft Cloud will then put the\ninstance into standby if there is no traffic to your service within the\nwindow of a cooldown period. When there is new traffic coming in, it is\nautomatically started again.\n\nIf you have a heavyweight application that takes long to cold boot or has\nbad first request latency (e.g., with JIT compilation) consider to enable\nstateful scale-to-zero.",
								},
								"service_group": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"domains": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"certificate": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Computed:            true,
																Description:         "The name of the certificate.\n\nThis is a human-readable name that can be used to identify the\ncertificate. The name is unique within the context of your account.\nThe name can also be used to identify the certificate in API calls.",
																MarkdownDescription: "The name of the certificate.\n\nThis is a human-readable name that can be used to identify the\ncertificate. The name is unique within the context of your account.\nThe name can also be used to identify the certificate in API calls.",
															},
														},
														CustomType: CertificateType{
															ObjectType: types.ObjectType{
																AttrTypes: CertificateValue{}.AttributeTypes(ctx),
															},
														},
														Computed:            true,
														Description:         "The certificate associated with the domain.",
														MarkdownDescription: "The certificate associated with the domain.",
													},
													"fqdn": schema.StringAttribute{
														Computed:            true,
														Description:         "Publicly accessible domain name.\n\nIf this name ends in a period `.` it must be a valid Full Qualified\nDomain Name (FQDN), otherwise it will become a subdomain of the target\nmetro.",
														MarkdownDescription: "Publicly accessible domain name.\n\nIf this name ends in a period `.` it must be a valid Full Qualified\nDomain Name (FQDN), otherwise it will become a subdomain of the target\nmetro.",
													},
												},
												CustomType: DomainsType{
													ObjectType: types.ObjectType{
														AttrTypes: DomainsValue{}.AttributeTypes(ctx),
													},
												},
											},
											Computed:            true,
											Description:         "The domain configuration for the service group.",
											MarkdownDescription: "The domain configuration for the service group.",
										},
										"name": schema.StringAttribute{
											Computed:            true,
											Description:         "The name of the service group.\n\nThis is a human-readable name that can be used to identify the service\ngroup.  The name is unique within the context of your account.  The name\ncan also be used to identify the service group in API calls.",
											MarkdownDescription: "The name of the service group.\n\nThis is a human-readable name that can be used to identify the service\ngroup.  The name is unique within the context of your account.  The name\ncan also be used to identify the service group in API calls.",
										},
										"uuid": schema.StringAttribute{
											Computed:            true,
											Description:         "The UUID of the service group.\n\nThis is a unique identifier for the service group that is generated when\nthe service is created.  The UUID is used to reference the service group\nin API calls and can be used to identify the service in all API calls\nthat require an service identifier.",
											MarkdownDescription: "The UUID of the service group.\n\nThis is a unique identifier for the service group that is generated when\nthe service is created.  The UUID is used to reference the service group\nin API calls and can be used to identify the service in all API calls\nthat require an service identifier.",
										},
									},
									CustomType: ServiceGroupType{
										ObjectType: types.ObjectType{
											AttrTypes: ServiceGroupValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "The service group configuration for the instance.",
									MarkdownDescription: "The service group configuration for the instance.",
								},
								"start_count": schema.Int64Attribute{
									Computed:            true,
									Description:         "The total number of times the instance has been started.  This is a counter\nthat increments each time the instance is started, regardless of whether it\nwas manually stopped or restarted.  This can be useful for tracking the\nusage of the instance over time and/or for debugging purposes.",
									MarkdownDescription: "The total number of times the instance has been started.  This is a counter\nthat increments each time the instance is started, regardless of whether it\nwas manually stopped or restarted.  This can be useful for tracking the\nusage of the instance over time and/or for debugging purposes.",
								},
								"started_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The time the instance was started.  This is the timestamp when the\ninstance was last started.",
									MarkdownDescription: "The time the instance was started.  This is the timestamp when the\ninstance was last started.",
								},
								"state": schema.StringAttribute{
									Computed:            true,
									Description:         "The state of the instance.  This indicates the current state of the\ninstance, such as whether it is running, stopped, or in an error state.",
									MarkdownDescription: "The state of the instance.  This indicates the current state of the\ninstance, such as whether it is running, stopped, or in an error state.",
								},
								"stop_code": schema.Int64Attribute{
									Computed:            true,
									Description:         "The kernel stop code.\n\nThis value encodes multiple details about the stop irrespective of the\napplication.\n\n```\nMSB                                                     LSB\n┌──────────────┬──────────┬──────────┬───────────┬────────┐\n│ 31 ────── 24 │ 23 ── 16 │    15    │ 14 ──── 8 │ 7 ── 0 │\n├──────────────┼──────────┼──────────┼───────────┼────────┤\n│ reserved[^1] │ errno    │ shutdown │ initlevel │ reason │\n└──────────────┴──────────┴──────────┴───────────┴────────┘\n```\n\n- **errno**:     The application errno, using Linux's errno.h values.\n                 (Optional, can be 0.)\n- **shutdown**:  Whether the shutdown originated from the inittable (0) or\n                 from the termtable (1).\n- **initlevel**: The initlevel at the time of the stop.\n- **reason**:    The reason for the stop. See `StopCodeReason`.\n\n[^1]: Reserved for future use.",
									MarkdownDescription: "The kernel stop code.\n\nThis value encodes multiple details about the stop irrespective of the\napplication.\n\n```\nMSB                                                     LSB\n┌──────────────┬──────────┬──────────┬───────────┬────────┐\n│ 31 ────── 24 │ 23 ── 16 │    15    │ 14 ──── 8 │ 7 ── 0 │\n├──────────────┼──────────┼──────────┼───────────┼────────┤\n│ reserved[^1] │ errno    │ shutdown │ initlevel │ reason │\n└──────────────┴──────────┴──────────┴───────────┴────────┘\n```\n\n- **errno**:     The application errno, using Linux's errno.h values.\n                 (Optional, can be 0.)\n- **shutdown**:  Whether the shutdown originated from the inittable (0) or\n                 from the termtable (1).\n- **initlevel**: The initlevel at the time of the stop.\n- **reason**:    The reason for the stop. See `StopCodeReason`.\n\n[^1]: Reserved for future use.",
								},
								"stop_reason": schema.Int64Attribute{
									Computed:            true,
									Description:         "The instance stop reason.\n\nProvides reason as to why an instance is stopped or in the process of\nshutting down.  The stop reason is a bitmask that tells you the origin of\nthe shutdown:\n\n| Bit     | 4          | 3          | 2          | 1          | 0 (LSB)      |\n|---------|------------|------------|------------|------------|--------------|\n| Purpose | [F]orced   | [U]ser     | [P]latform | [A]pp      | [K]ernel     |\n\n- **Forced**:   This was a force stop.  A forced stop does not give the\n                instance a chance to perform a clean shutdown.  Bits 0\n                (Kernel) and 1 (App) can thus never be set for forced\n                shutdowns.  Consequently, there won't be an `exit_code` or\n                `stop_code`.\n- **User**:     Stop initiated by user, e.g. via an API call.\n- **Platform**: Stop initiated by platform, e.g. an autoscale policy.\n- **App**:      The Application exited.  The `exit_code` field will be set.\n- **Kernel**:   The kernel exited.  The `stop_code` field will be set.\n\nFor example, the stop reason will contain the following values in the given\nscenarios:\n\n| Value | Bitmask | Aliases | Scenario |\n|-------|---------|---------|----------|\n| 28    | `11100` | `FUP--` | Forced user-initiated shutdown. |\n| 15    | `01111` | `-UPAK` | Regular user-initiated shutdown. The application and kernel have exited. The exit_code and stop_code indicate if the application and kernel shut down cleanly. |\n| 13    | `01101` | `-UP-K` | The user initiated a shutdown but the application was forcefully killed by the kernel during shutdown. This can be the case if the image does not support a clean application exit or the application crashed after receiving a termination signal. The exit_code won’t be present in this scenario. |\n| 7     | `00111` | `--PAK` | Unikraft Cloud initiated the shutdown, for example, due to scale-to-zero. The application and kernel have exited. The exit_code and stop_code indicate if the application and kernel shut down cleanly. |\n| 3     | `00011` | `---AK` | The application exited. The exit_code and stop_code indicate if the application and kernel shut down cleanly. |\n| 1     | `00001` | `----K` | The instance likely expierenced a fatal crash and the stop_code contains more information about the cause of the crash. |\n| 0     | `00000` | `-----` | The stop reason is unknown. |",
									MarkdownDescription: "The instance stop reason.\n\nProvides reason as to why an instance is stopped or in the process of\nshutting down.  The stop reason is a bitmask that tells you the origin of\nthe shutdown:\n\n| Bit     | 4          | 3          | 2          | 1          | 0 (LSB)      |\n|---------|------------|------------|------------|------------|--------------|\n| Purpose | [F]orced   | [U]ser     | [P]latform | [A]pp      | [K]ernel     |\n\n- **Forced**:   This was a force stop.  A forced stop does not give the\n                instance a chance to perform a clean shutdown.  Bits 0\n                (Kernel) and 1 (App) can thus never be set for forced\n                shutdowns.  Consequently, there won't be an `exit_code` or\n                `stop_code`.\n- **User**:     Stop initiated by user, e.g. via an API call.\n- **Platform**: Stop initiated by platform, e.g. an autoscale policy.\n- **App**:      The Application exited.  The `exit_code` field will be set.\n- **Kernel**:   The kernel exited.  The `stop_code` field will be set.\n\nFor example, the stop reason will contain the following values in the given\nscenarios:\n\n| Value | Bitmask | Aliases | Scenario |\n|-------|---------|---------|----------|\n| 28    | `11100` | `FUP--` | Forced user-initiated shutdown. |\n| 15    | `01111` | `-UPAK` | Regular user-initiated shutdown. The application and kernel have exited. The exit_code and stop_code indicate if the application and kernel shut down cleanly. |\n| 13    | `01101` | `-UP-K` | The user initiated a shutdown but the application was forcefully killed by the kernel during shutdown. This can be the case if the image does not support a clean application exit or the application crashed after receiving a termination signal. The exit_code won’t be present in this scenario. |\n| 7     | `00111` | `--PAK` | Unikraft Cloud initiated the shutdown, for example, due to scale-to-zero. The application and kernel have exited. The exit_code and stop_code indicate if the application and kernel shut down cleanly. |\n| 3     | `00011` | `---AK` | The application exited. The exit_code and stop_code indicate if the application and kernel shut down cleanly. |\n| 1     | `00001` | `----K` | The instance likely expierenced a fatal crash and the stop_code contains more information about the cause of the crash. |\n| 0     | `00000` | `-----` | The stop reason is unknown. |",
								},
								"stopped_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The time the instance was stopped.  This is the timestamp when the\ninstance was last stopped.  If the instance is currently running, this\nfield will be empty.",
									MarkdownDescription: "The time the instance was stopped.  This is the timestamp when the\ninstance was last stopped.  If the instance is currently running, this\nfield will be empty.",
								},
								"uptime_ms": schema.Int64Attribute{
									Computed:            true,
									Description:         "The total amount of time the instance has been running in milliseconds.",
									MarkdownDescription: "The total amount of time the instance has been running in milliseconds.",
								},
								"uuid": schema.StringAttribute{
									Computed:            true,
									Description:         "The UUID of the instance.\n\nThis is a unique identifier for the instance that is generated when the\ninstance is created.  The UUID is used to reference the instance in API\ncalls and can be used to identify the instance in all API calls that\nrequire an instance identifier.",
									MarkdownDescription: "The UUID of the instance.\n\nThis is a unique identifier for the instance that is generated when the\ninstance is created.  The UUID is used to reference the instance in API\ncalls and can be used to identify the instance in all API calls that\nrequire an instance identifier.",
								},
								"vcpus": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of vCPUs allocated for the instance.  This is the total\nnumber of virtual CPUs that are available to the instance for its\noperations.",
									MarkdownDescription: "The number of vCPUs allocated for the instance.  This is the total\nnumber of virtual CPUs that are available to the instance for its\noperations.",
								},
								"vmm_load_time_us": schema.Int64Attribute{
									Computed:            true,
									Description:         "(Developer-only).  The time it took the VMM (Virtual Machine Monitor) to\nload the instance's kernel and initramfs into VM memory measured in\nmicroseconds.  This field is primarily used for debugging and performance\nanalysis purposes.",
									MarkdownDescription: "(Developer-only).  The time it took the VMM (Virtual Machine Monitor) to\nload the instance's kernel and initramfs into VM memory measured in\nmicroseconds.  This field is primarily used for debugging and performance\nanalysis purposes.",
								},
								"vmm_ready_time_us": schema.Int64Attribute{
									Computed:            true,
									Description:         "(Developer-only).  The time taken for the VMM (Virtual Machine Monitor) to\nbecome ready to execute the instance measured in microseconds.  This is the\ntime from when the VMM started until it was ready to execute the instance's\ncode.  This field is primarily used for debugging and performance analysis\npurposes.",
									MarkdownDescription: "(Developer-only).  The time taken for the VMM (Virtual Machine Monitor) to\nbecome ready to execute the instance measured in microseconds.  This is the\ntime from when the VMM started until it was ready to execute the instance's\ncode.  This field is primarily used for debugging and performance analysis\npurposes.",
								},
								"vmm_start_time_us": schema.Int64Attribute{
									Computed:            true,
									Description:         "(Developer-only).  The time taken between the main controller and the\nbeginning of execution of the VMM (Virtual Machine Monitor) measured in\nmicroseconds.  This field is primarily used for debugging and performance\nanalysis purposes.",
									MarkdownDescription: "(Developer-only).  The time taken between the main controller and the\nbeginning of execution of the VMM (Virtual Machine Monitor) measured in\nmicroseconds.  This field is primarily used for debugging and performance\nanalysis purposes.",
								},
								"volumes": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"at": schema.StringAttribute{
												Computed:            true,
												Description:         "The mount point of the volume in the instance.  This is the directory in\nthe instance where the volume will be mounted.",
												MarkdownDescription: "The mount point of the volume in the instance.  This is the directory in\nthe instance where the volume will be mounted.",
											},
											"name": schema.StringAttribute{
												Computed:            true,
												Description:         "The name of the volume.\n\nThis is a human-readable name that can be used to identify the volume.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the volume in API calls.",
												MarkdownDescription: "The name of the volume.\n\nThis is a human-readable name that can be used to identify the volume.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the volume in API calls.",
											},
											"read_only": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether the volume is read-only or not.",
												MarkdownDescription: "Whether the volume is read-only or not.",
											},
											"uuid": schema.StringAttribute{
												Computed:            true,
												Description:         "The UUID of the volume.\n\nThis is a unique identifier for the volume that is generated when the\nvolume is created.  The UUID is used to reference the volume in API calls\nand can be used to identify the volume in all API calls that require a\nvolume identifier.",
												MarkdownDescription: "The UUID of the volume.\n\nThis is a unique identifier for the volume that is generated when the\nvolume is created.  The UUID is used to reference the volume in API calls\nand can be used to identify the volume in all API calls that require a\nvolume identifier.",
											},
										},
										CustomType: VolumesType{
											ObjectType: types.ObjectType{
												AttrTypes: VolumesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "The list of volumes attached to the instance.",
									MarkdownDescription: "The list of volumes attached to the instance.",
								},
							},
							CustomType: InstancesType{
								ObjectType: types.ObjectType{
									AttrTypes: InstancesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "The instance(s) that were retrieved by the request.",
						MarkdownDescription: "The instance(s) that were retrieved by the request.",
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "The response data for this request.",
				MarkdownDescription: "The response data for this request.",
			},
			"details": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to include details about the instance in the response.  By default\nthis is set to true, meaning that all information about the instance will\nbe included in the response.  If set to false, only the basic information\nabout the instance will be included, such as its name and UUID.",
				MarkdownDescription: "Whether to include details about the instance in the response.  By default\nthis is set to true, meaning that all information about the instance will\nbe included in the response.  If set to false, only the basic information\nabout the instance will be included, such as its name and UUID.",
			},
			"env": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  Environment variables to set for the instance.",
				MarkdownDescription: "(Optional).  Environment variables to set for the instance.",
			},
			"features": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Features to enable for the instance.  Features are specific\nconfigurations or capabilities that can be enabled for the instance.",
				MarkdownDescription: "Features to enable for the instance.  Features are specific\nconfigurations or capabilities that can be enabled for the instance.",
			},
			"image": schema.StringAttribute{
				Required:            true,
				Description:         "The image to use for the instance.",
				MarkdownDescription: "The image to use for the instance.",
			},
			"memory_mb": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  Memory in MB to allocate for the instance.  Default is 128.",
				MarkdownDescription: "(Optional).  Memory in MB to allocate for the instance.  Default is 128.",
			},
			"message": schema.StringAttribute{
				Computed:            true,
				Description:         "An optional message providing additional information about the response.",
				MarkdownDescription: "An optional message providing additional information about the response.",
			},
			"metrics": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to include metrics about the instance in the response.  By default\nthis is set to false, meaning that no metrics will be included in the\nresponse.",
				MarkdownDescription: "Whether to include metrics about the instance in the response.  By default\nthis is set to false, meaning that no metrics will be included in the\nresponse.",
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  The name of the instance.\n\nIf not provided, a random name will be generated. The name must be unique.",
				MarkdownDescription: "(Optional).  The name of the instance.\n\nIf not provided, a random name will be generated. The name must be unique.",
			},
			"op_time_us": schema.Int64Attribute{
				Computed:            true,
				Description:         "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
				MarkdownDescription: "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
			},
			"replicas": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of replicas for the instance.",
				MarkdownDescription: "Number of replicas for the instance.",
			},
			"restart_policy": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Restart policy for the instance.  This defines how the instance should\nbehave when it stops or crashes.",
				MarkdownDescription: "Restart policy for the instance.  This defines how the instance should\nbehave when it stops or crashes.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"never",
						"always",
						"on_failure",
					),
				},
			},
			"scale_to_zero": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cooldown_time_ms": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The cooldown time in milliseconds before the instance can be scaled to\nzero again.  This is useful to prevent rapid scaling to zero and back up,\nwhich can lead to performance issues or resource exhaustion.",
						MarkdownDescription: "The cooldown time in milliseconds before the instance can be scaled to\nzero again.  This is useful to prevent rapid scaling to zero and back up,\nwhich can lead to performance issues or resource exhaustion.",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates whether scale-to-zero is enabled for the instance.",
						MarkdownDescription: "Indicates whether scale-to-zero is enabled for the instance.",
					},
					"policy": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The specific policy to use for scaling the instance to zero.",
						MarkdownDescription: "The specific policy to use for scaling the instance to zero.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"on",
								"off",
								"idle",
							),
						},
					},
					"stateful": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether the instance should be stateful when scaled to zero. If set to\ntrue, the instance will retain its state (e.g., RAM contents) when scaled\nto zero.  This is useful for instances that need to maintain their state\nacross scale-to-zero operations.  If set to false, the instance will lose\nits state when scaled to zero, and it will be restarted from scratch when\nscaled back up.",
						MarkdownDescription: "Whether the instance should be stateful when scaled to zero. If set to\ntrue, the instance will retain its state (e.g., RAM contents) when scaled\nto zero.  This is useful for instances that need to maintain their state\nacross scale-to-zero operations.  If set to false, the instance will lose\nits state when scaled to zero, and it will be restarted from scratch when\nscaled back up.",
					},
				},
				CustomType: ScaleToZeroType{
					ObjectType: types.ObjectType{
						AttrTypes: ScaleToZeroValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Scale-to-zero configuration for the instance.",
				MarkdownDescription: "Scale-to-zero configuration for the instance.",
			},
			"service_group": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"domains": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"certificate": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "(Optional).  The name of the existing certificate. Mutually exclusive with UUID.",
											MarkdownDescription: "(Optional).  The name of the existing certificate. Mutually exclusive with UUID.",
										},
										"uuid": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "(Optional).  The UUID for the existing certificate. Mutually exclusive with name.",
											MarkdownDescription: "(Optional).  The UUID for the existing certificate. Mutually exclusive with name.",
										},
									},
									CustomType: CertificateType{
										ObjectType: types.ObjectType{
											AttrTypes: CertificateValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "A reference to an existing certificate which can be used for the specified domain.  If unspecified, Unikraft Cloud will automatically generate a new certificate for the domain based on Let's Encrypt and seek to accomplish a DNS-01 challenge.",
									MarkdownDescription: "A reference to an existing certificate which can be used for the specified domain.  If unspecified, Unikraft Cloud will automatically generate a new certificate for the domain based on Let's Encrypt and seek to accomplish a DNS-01 challenge.",
								},
								"name": schema.StringAttribute{
									Required:            true,
									Description:         "Publicly accessible domain name.\n\nIf this name ends in a period `.` it must be a valid Full Qualified\nDomain Name (FQDN), e.g. `example.com.`; otherwise it will become\nsubdomain of the target metro, e.g. `example` becomes `example.fra0.unikraft.app`.",
									MarkdownDescription: "Publicly accessible domain name.\n\nIf this name ends in a period `.` it must be a valid Full Qualified\nDomain Name (FQDN), e.g. `example.com.`; otherwise it will become\nsubdomain of the target metro, e.g. `example` becomes `example.fra0.unikraft.app`.",
								},
							},
							CustomType: DomainsType{
								ObjectType: types.ObjectType{
									AttrTypes: DomainsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Similarly, if no existing (persistent) service group is specified via its identifier, a new (ephemeral) service group can be created.  In addition to the services it must expose, you can specify which domains it should use too.",
						MarkdownDescription: "Similarly, if no existing (persistent) service group is specified via its identifier, a new (ephemeral) service group can be created.  In addition to the services it must expose, you can specify which domains it should use too.",
					},
					"name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "(Optional).  Reference an existing (persistent) service group by its name. Mutually exclusive with UUID.",
						MarkdownDescription: "(Optional).  Reference an existing (persistent) service group by its name. Mutually exclusive with UUID.",
					},
					"uuid": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "(Optional).  Reference an existing (persistent) service group by its UUID. Mutually exclusive with name.",
						MarkdownDescription: "(Optional).  Reference an existing (persistent) service group by its UUID. Mutually exclusive with name.",
					},
				},
				CustomType: ServiceGroupType{
					ObjectType: types.ObjectType{
						AttrTypes: ServiceGroupValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "(Optional).  The service group configuration when creating an instance.\n\nWhen creating an instance, either a previously created (persistent) service\ngroup can be referenced (either through its name or UUID), or a new\n(ephemeral) service group can be created for the instance by specifying the\nlist of services it should expose and optionally the domains it should use.",
				MarkdownDescription: "(Optional).  The service group configuration when creating an instance.\n\nWhen creating an instance, either a previously created (persistent) service\ngroup can be referenced (either through its name or UUID), or a new\n(ephemeral) service group can be created for the instance by specifying the\nlist of services it should expose and optionally the domains it should use.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "The status of the response.",
				MarkdownDescription: "The status of the response.",
			},
			"uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The UUID of the instance to get.",
				MarkdownDescription: "The UUID of the instance to get.",
			},
			"vcpus": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of vCPUs to allocate for the instance.",
				MarkdownDescription: "Number of vCPUs to allocate for the instance.",
			},
			"volumes": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"at": schema.StringAttribute{
							Required:            true,
							Description:         "The mount point for the volume in the instance.",
							MarkdownDescription: "The mount point for the volume in the instance.",
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The name of the volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this name.  If the volume does not exist, the request will\nfail.  If a new volume is intended to be created, then this field must be\nspecified along with the size in MiB and the mount point in the instance.",
							MarkdownDescription: "The name of the volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this name.  If the volume does not exist, the request will\nfail.  If a new volume is intended to be created, then this field must be\nspecified along with the size in MiB and the mount point in the instance.",
						},
						"read_only": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Whether the volume is read-only.\n\nIf this field is set to true, the volume will be mounted as read-only in\nthe instance.  This field is optional and defaults to false and is only\napplicable when using an existing volume.",
							MarkdownDescription: "Whether the volume is read-only.\n\nIf this field is set to true, the volume will be mounted as read-only in\nthe instance.  This field is optional and defaults to false and is only\napplicable when using an existing volume.",
						},
						"size_mb": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "The size of the volume when creating a new volume.\n\nWhen creating a new volume as part of the instance create request,\nspecify the size of the volume in MiB.",
							MarkdownDescription: "The size of the volume when creating a new volume.\n\nWhen creating a new volume as part of the instance create request,\nspecify the size of the volume in MiB.",
						},
						"uuid": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The UUID of an existing volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this UUID.",
							MarkdownDescription: "The UUID of an existing volume.\n\nIf this is the only specified field, then it will look up an existing\nvolume by this UUID.",
						},
					},
					CustomType: VolumesType{
						ObjectType: types.ObjectType{
							AttrTypes: VolumesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Volumes to attach to the instance.\n\nThis list can contain both existing and new volumes to create as part of\nthe instance creation.  Existing volumes can be referenced by their name or\nUUID.  New volumes can be created by specifying a name, size in MiB, and\nmount point in the instance.  The mount point is the directory in the\ninstance where the volume will be mounted.",
				MarkdownDescription: "Volumes to attach to the instance.\n\nThis list can contain both existing and new volumes to create as part of\nthe instance creation.  Existing volumes can be referenced by their name or\nUUID.  New volumes can be created by specifying a name, size in MiB, and\nmount point in the instance.  The mount point is the directory in the\ninstance where the volume will be mounted.",
			},
			"wait_timeout_ms": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Timeout to wait for all new instances to reach running state in\nmilliseconds.  If you autostart your new instance, you can wait for it to\nfinish starting with a blocking API call if you specify a wait timeout\ngreater than zero.  No wait performed for a value of 0.",
				MarkdownDescription: "Timeout to wait for all new instances to reach running state in\nmilliseconds.  If you autostart your new instance, you can wait for it to\nfinish starting with a blocking API call if you specify a wait timeout\ngreater than zero.  No wait performed for a value of 0.",
			},
		},
	}
}

type InstanceModel struct {
	Args          types.List        `tfsdk:"args"`
	Autostart     types.Bool        `tfsdk:"autostart"`
	Data          DataValue         `tfsdk:"data"`
	Details       types.Bool        `tfsdk:"details"`
	Env           types.Map         `tfsdk:"env"`
	Features      types.List        `tfsdk:"features"`
	Image         types.String      `tfsdk:"image"`
	MemoryMb      types.Int64       `tfsdk:"memory_mb"`
	Message       types.String      `tfsdk:"message"`
	Metrics       types.Bool        `tfsdk:"metrics"`
	Name          types.String      `tfsdk:"name"`
	OpTimeUs      types.Int64       `tfsdk:"op_time_us"`
	Replicas      types.Int64       `tfsdk:"replicas"`
	RestartPolicy types.String      `tfsdk:"restart_policy"`
	ScaleToZero   ScaleToZeroValue  `tfsdk:"scale_to_zero"`
	ServiceGroup  ServiceGroupValue `tfsdk:"service_group"`
	Status        types.String      `tfsdk:"status"`
	Uuid          types.String      `tfsdk:"uuid"`
	Vcpus         types.Int64       `tfsdk:"vcpus"`
	Volumes       types.List        `tfsdk:"volumes"`
	WaitTimeoutMs types.Int64       `tfsdk:"wait_timeout_ms"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	instancesAttribute, ok := attributes["instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances is missing from object`)

		return nil, diags
	}

	instancesVal, ok := instancesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances expected to be basetypes.ListValue, was: %T`, instancesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Instances: instancesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	instancesAttribute, ok := attributes["instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instances is missing from object`)

		return NewDataValueUnknown(), diags
	}

	instancesVal, ok := instancesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instances expected to be basetypes.ListValue, was: %T`, instancesAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Instances: instancesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Instances basetypes.ListValue `tfsdk:"instances"`
	state     attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["instances"] = basetypes.ListType{
		ElemType: InstancesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Instances.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instances"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	instances := types.ListValueMust(
		InstancesType{
			basetypes.ObjectType{
				AttrTypes: InstancesValue{}.AttributeTypes(ctx),
			},
		},
		v.Instances.Elements(),
	)

	if v.Instances.IsNull() {
		instances = types.ListNull(
			InstancesType{
				basetypes.ObjectType{
					AttrTypes: InstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Instances.IsUnknown() {
		instances = types.ListUnknown(
			InstancesType{
				basetypes.ObjectType{
					AttrTypes: InstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"instances": basetypes.ListType{
			ElemType: InstancesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"instances": instances,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Instances.Equal(other.Instances) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"instances": basetypes.ListType{
			ElemType: InstancesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = InstancesType{}

type InstancesType struct {
	basetypes.ObjectType
}

func (t InstancesType) Equal(o attr.Type) bool {
	other, ok := o.(InstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstancesType) String() string {
	return "InstancesType"
}

func (t InstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	argsAttribute, ok := attributes["args"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`args is missing from object`)

		return nil, diags
	}

	argsVal, ok := argsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`args expected to be basetypes.ListValue, was: %T`, argsAttribute))
	}

	bootTimeUsAttribute, ok := attributes["boot_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`boot_time_us is missing from object`)

		return nil, diags
	}

	bootTimeUsVal, ok := bootTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`boot_time_us expected to be basetypes.Int64Value, was: %T`, bootTimeUsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	exitCodeAttribute, ok := attributes["exit_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exit_code is missing from object`)

		return nil, diags
	}

	exitCodeVal, ok := exitCodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exit_code expected to be basetypes.Int64Value, was: %T`, exitCodeAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	memoryMbAttribute, ok := attributes["memory_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_mb is missing from object`)

		return nil, diags
	}

	memoryMbVal, ok := memoryMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_mb expected to be basetypes.Int64Value, was: %T`, memoryMbAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netTimeUsAttribute, ok := attributes["net_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_time_us is missing from object`)

		return nil, diags
	}

	netTimeUsVal, ok := netTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_time_us expected to be basetypes.Int64Value, was: %T`, netTimeUsAttribute))
	}

	networkInterfacesAttribute, ok := attributes["network_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_interfaces is missing from object`)

		return nil, diags
	}

	networkInterfacesVal, ok := networkInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_interfaces expected to be basetypes.ListValue, was: %T`, networkInterfacesAttribute))
	}

	privateFqdnAttribute, ok := attributes["private_fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_fqdn is missing from object`)

		return nil, diags
	}

	privateFqdnVal, ok := privateFqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_fqdn expected to be basetypes.StringValue, was: %T`, privateFqdnAttribute))
	}

	restartPolicyAttribute, ok := attributes["restart_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restart_policy is missing from object`)

		return nil, diags
	}

	restartPolicyVal, ok := restartPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restart_policy expected to be basetypes.StringValue, was: %T`, restartPolicyAttribute))
	}

	scaleToZeroAttribute, ok := attributes["scale_to_zero"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scale_to_zero is missing from object`)

		return nil, diags
	}

	scaleToZeroVal, ok := scaleToZeroAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scale_to_zero expected to be basetypes.ObjectValue, was: %T`, scaleToZeroAttribute))
	}

	serviceGroupAttribute, ok := attributes["service_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_group is missing from object`)

		return nil, diags
	}

	serviceGroupVal, ok := serviceGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_group expected to be basetypes.ObjectValue, was: %T`, serviceGroupAttribute))
	}

	startCountAttribute, ok := attributes["start_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_count is missing from object`)

		return nil, diags
	}

	startCountVal, ok := startCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_count expected to be basetypes.Int64Value, was: %T`, startCountAttribute))
	}

	startedAtAttribute, ok := attributes["started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`started_at is missing from object`)

		return nil, diags
	}

	startedAtVal, ok := startedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`started_at expected to be basetypes.StringValue, was: %T`, startedAtAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	stopCodeAttribute, ok := attributes["stop_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stop_code is missing from object`)

		return nil, diags
	}

	stopCodeVal, ok := stopCodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stop_code expected to be basetypes.Int64Value, was: %T`, stopCodeAttribute))
	}

	stopReasonAttribute, ok := attributes["stop_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stop_reason is missing from object`)

		return nil, diags
	}

	stopReasonVal, ok := stopReasonAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stop_reason expected to be basetypes.Int64Value, was: %T`, stopReasonAttribute))
	}

	stoppedAtAttribute, ok := attributes["stopped_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stopped_at is missing from object`)

		return nil, diags
	}

	stoppedAtVal, ok := stoppedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stopped_at expected to be basetypes.StringValue, was: %T`, stoppedAtAttribute))
	}

	uptimeMsAttribute, ok := attributes["uptime_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime_ms is missing from object`)

		return nil, diags
	}

	uptimeMsVal, ok := uptimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime_ms expected to be basetypes.Int64Value, was: %T`, uptimeMsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	vmmLoadTimeUsAttribute, ok := attributes["vmm_load_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vmm_load_time_us is missing from object`)

		return nil, diags
	}

	vmmLoadTimeUsVal, ok := vmmLoadTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vmm_load_time_us expected to be basetypes.Int64Value, was: %T`, vmmLoadTimeUsAttribute))
	}

	vmmReadyTimeUsAttribute, ok := attributes["vmm_ready_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vmm_ready_time_us is missing from object`)

		return nil, diags
	}

	vmmReadyTimeUsVal, ok := vmmReadyTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vmm_ready_time_us expected to be basetypes.Int64Value, was: %T`, vmmReadyTimeUsAttribute))
	}

	vmmStartTimeUsAttribute, ok := attributes["vmm_start_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vmm_start_time_us is missing from object`)

		return nil, diags
	}

	vmmStartTimeUsVal, ok := vmmStartTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vmm_start_time_us expected to be basetypes.Int64Value, was: %T`, vmmStartTimeUsAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.ListValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstancesValue{
		Args:              argsVal,
		BootTimeUs:        bootTimeUsVal,
		CreatedAt:         createdAtVal,
		ExitCode:          exitCodeVal,
		Image:             imageVal,
		MemoryMb:          memoryMbVal,
		Name:              nameVal,
		NetTimeUs:         netTimeUsVal,
		NetworkInterfaces: networkInterfacesVal,
		PrivateFqdn:       privateFqdnVal,
		RestartPolicy:     restartPolicyVal,
		ScaleToZero:       scaleToZeroVal,
		ServiceGroup:      serviceGroupVal,
		StartCount:        startCountVal,
		StartedAt:         startedAtVal,
		State:             stateVal,
		StopCode:          stopCodeVal,
		StopReason:        stopReasonVal,
		StoppedAt:         stoppedAtVal,
		UptimeMs:          uptimeMsVal,
		Uuid:              uuidVal,
		Vcpus:             vcpusVal,
		VmmLoadTimeUs:     vmmLoadTimeUsVal,
		VmmReadyTimeUs:    vmmReadyTimeUsVal,
		VmmStartTimeUs:    vmmStartTimeUsVal,
		Volumes:           volumesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInstancesValueNull() InstancesValue {
	return InstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewInstancesValueUnknown() InstancesValue {
	return InstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstancesValue Attribute Value",
				"While creating a InstancesValue value, a missing attribute value was detected. "+
					"A InstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstancesValue Attribute Type",
				"While creating a InstancesValue value, an invalid attribute value was detected. "+
					"A InstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstancesValue Attribute Value",
				"While creating a InstancesValue value, an extra attribute value was detected. "+
					"A InstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstancesValueUnknown(), diags
	}

	argsAttribute, ok := attributes["args"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`args is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	argsVal, ok := argsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`args expected to be basetypes.ListValue, was: %T`, argsAttribute))
	}

	bootTimeUsAttribute, ok := attributes["boot_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`boot_time_us is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	bootTimeUsVal, ok := bootTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`boot_time_us expected to be basetypes.Int64Value, was: %T`, bootTimeUsAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	exitCodeAttribute, ok := attributes["exit_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exit_code is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	exitCodeVal, ok := exitCodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exit_code expected to be basetypes.Int64Value, was: %T`, exitCodeAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	memoryMbAttribute, ok := attributes["memory_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_mb is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	memoryMbVal, ok := memoryMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_mb expected to be basetypes.Int64Value, was: %T`, memoryMbAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	netTimeUsAttribute, ok := attributes["net_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`net_time_us is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	netTimeUsVal, ok := netTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`net_time_us expected to be basetypes.Int64Value, was: %T`, netTimeUsAttribute))
	}

	networkInterfacesAttribute, ok := attributes["network_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_interfaces is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	networkInterfacesVal, ok := networkInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_interfaces expected to be basetypes.ListValue, was: %T`, networkInterfacesAttribute))
	}

	privateFqdnAttribute, ok := attributes["private_fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_fqdn is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	privateFqdnVal, ok := privateFqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_fqdn expected to be basetypes.StringValue, was: %T`, privateFqdnAttribute))
	}

	restartPolicyAttribute, ok := attributes["restart_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restart_policy is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	restartPolicyVal, ok := restartPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restart_policy expected to be basetypes.StringValue, was: %T`, restartPolicyAttribute))
	}

	scaleToZeroAttribute, ok := attributes["scale_to_zero"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scale_to_zero is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	scaleToZeroVal, ok := scaleToZeroAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scale_to_zero expected to be basetypes.ObjectValue, was: %T`, scaleToZeroAttribute))
	}

	serviceGroupAttribute, ok := attributes["service_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_group is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	serviceGroupVal, ok := serviceGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_group expected to be basetypes.ObjectValue, was: %T`, serviceGroupAttribute))
	}

	startCountAttribute, ok := attributes["start_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_count is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	startCountVal, ok := startCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_count expected to be basetypes.Int64Value, was: %T`, startCountAttribute))
	}

	startedAtAttribute, ok := attributes["started_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`started_at is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	startedAtVal, ok := startedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`started_at expected to be basetypes.StringValue, was: %T`, startedAtAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	stopCodeAttribute, ok := attributes["stop_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stop_code is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	stopCodeVal, ok := stopCodeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stop_code expected to be basetypes.Int64Value, was: %T`, stopCodeAttribute))
	}

	stopReasonAttribute, ok := attributes["stop_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stop_reason is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	stopReasonVal, ok := stopReasonAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stop_reason expected to be basetypes.Int64Value, was: %T`, stopReasonAttribute))
	}

	stoppedAtAttribute, ok := attributes["stopped_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stopped_at is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	stoppedAtVal, ok := stoppedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stopped_at expected to be basetypes.StringValue, was: %T`, stoppedAtAttribute))
	}

	uptimeMsAttribute, ok := attributes["uptime_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime_ms is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	uptimeMsVal, ok := uptimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime_ms expected to be basetypes.Int64Value, was: %T`, uptimeMsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	vmmLoadTimeUsAttribute, ok := attributes["vmm_load_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vmm_load_time_us is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	vmmLoadTimeUsVal, ok := vmmLoadTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vmm_load_time_us expected to be basetypes.Int64Value, was: %T`, vmmLoadTimeUsAttribute))
	}

	vmmReadyTimeUsAttribute, ok := attributes["vmm_ready_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vmm_ready_time_us is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	vmmReadyTimeUsVal, ok := vmmReadyTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vmm_ready_time_us expected to be basetypes.Int64Value, was: %T`, vmmReadyTimeUsAttribute))
	}

	vmmStartTimeUsAttribute, ok := attributes["vmm_start_time_us"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vmm_start_time_us is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	vmmStartTimeUsVal, ok := vmmStartTimeUsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vmm_start_time_us expected to be basetypes.Int64Value, was: %T`, vmmStartTimeUsAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewInstancesValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.ListValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewInstancesValueUnknown(), diags
	}

	return InstancesValue{
		Args:              argsVal,
		BootTimeUs:        bootTimeUsVal,
		CreatedAt:         createdAtVal,
		ExitCode:          exitCodeVal,
		Image:             imageVal,
		MemoryMb:          memoryMbVal,
		Name:              nameVal,
		NetTimeUs:         netTimeUsVal,
		NetworkInterfaces: networkInterfacesVal,
		PrivateFqdn:       privateFqdnVal,
		RestartPolicy:     restartPolicyVal,
		ScaleToZero:       scaleToZeroVal,
		ServiceGroup:      serviceGroupVal,
		StartCount:        startCountVal,
		StartedAt:         startedAtVal,
		State:             stateVal,
		StopCode:          stopCodeVal,
		StopReason:        stopReasonVal,
		StoppedAt:         stoppedAtVal,
		UptimeMs:          uptimeMsVal,
		Uuid:              uuidVal,
		Vcpus:             vcpusVal,
		VmmLoadTimeUs:     vmmLoadTimeUsVal,
		VmmReadyTimeUs:    vmmReadyTimeUsVal,
		VmmStartTimeUs:    vmmStartTimeUsVal,
		Volumes:           volumesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstancesValue {
	object, diags := NewInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstancesValueMust(InstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstancesType) ValueType(ctx context.Context) attr.Value {
	return InstancesValue{}
}

var _ basetypes.ObjectValuable = InstancesValue{}

type InstancesValue struct {
	Args              basetypes.ListValue   `tfsdk:"args"`
	BootTimeUs        basetypes.Int64Value  `tfsdk:"boot_time_us"`
	CreatedAt         basetypes.StringValue `tfsdk:"created_at"`
	ExitCode          basetypes.Int64Value  `tfsdk:"exit_code"`
	Image             basetypes.StringValue `tfsdk:"image"`
	MemoryMb          basetypes.Int64Value  `tfsdk:"memory_mb"`
	Name              basetypes.StringValue `tfsdk:"name"`
	NetTimeUs         basetypes.Int64Value  `tfsdk:"net_time_us"`
	NetworkInterfaces basetypes.ListValue   `tfsdk:"network_interfaces"`
	PrivateFqdn       basetypes.StringValue `tfsdk:"private_fqdn"`
	RestartPolicy     basetypes.StringValue `tfsdk:"restart_policy"`
	ScaleToZero       basetypes.ObjectValue `tfsdk:"scale_to_zero"`
	ServiceGroup      basetypes.ObjectValue `tfsdk:"service_group"`
	StartCount        basetypes.Int64Value  `tfsdk:"start_count"`
	StartedAt         basetypes.StringValue `tfsdk:"started_at"`
	State             basetypes.StringValue `tfsdk:"state"`
	StopCode          basetypes.Int64Value  `tfsdk:"stop_code"`
	StopReason        basetypes.Int64Value  `tfsdk:"stop_reason"`
	StoppedAt         basetypes.StringValue `tfsdk:"stopped_at"`
	UptimeMs          basetypes.Int64Value  `tfsdk:"uptime_ms"`
	Uuid              basetypes.StringValue `tfsdk:"uuid"`
	Vcpus             basetypes.Int64Value  `tfsdk:"vcpus"`
	VmmLoadTimeUs     basetypes.Int64Value  `tfsdk:"vmm_load_time_us"`
	VmmReadyTimeUs    basetypes.Int64Value  `tfsdk:"vmm_ready_time_us"`
	VmmStartTimeUs    basetypes.Int64Value  `tfsdk:"vmm_start_time_us"`
	Volumes           basetypes.ListValue   `tfsdk:"volumes"`
	state             attr.ValueState
}

func (v InstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 26)

	var val tftypes.Value
	var err error

	attrTypes["args"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["boot_time_us"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["exit_code"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory_mb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["net_time_us"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network_interfaces"] = basetypes.ListType{
		ElemType: NetworkInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["private_fqdn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["restart_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scale_to_zero"] = basetypes.ObjectType{
		AttrTypes: ScaleToZeroValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["service_group"] = basetypes.ObjectType{
		AttrTypes: ServiceGroupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["start_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["started_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stop_code"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["stop_reason"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["stopped_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vmm_load_time_us"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vmm_ready_time_us"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vmm_start_time_us"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.ListType{
		ElemType: VolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 26)

		val, err = v.Args.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["args"] = val

		val, err = v.BootTimeUs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["boot_time_us"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.ExitCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exit_code"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.MemoryMb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_mb"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NetTimeUs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["net_time_us"] = val

		val, err = v.NetworkInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_interfaces"] = val

		val, err = v.PrivateFqdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_fqdn"] = val

		val, err = v.RestartPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restart_policy"] = val

		val, err = v.ScaleToZero.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scale_to_zero"] = val

		val, err = v.ServiceGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_group"] = val

		val, err = v.StartCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_count"] = val

		val, err = v.StartedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["started_at"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.StopCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stop_code"] = val

		val, err = v.StopReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stop_reason"] = val

		val, err = v.StoppedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stopped_at"] = val

		val, err = v.UptimeMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime_ms"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		val, err = v.VmmLoadTimeUs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vmm_load_time_us"] = val

		val, err = v.VmmReadyTimeUs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vmm_ready_time_us"] = val

		val, err = v.VmmStartTimeUs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vmm_start_time_us"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstancesValue) String() string {
	return "InstancesValue"
}

func (v InstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networkInterfaces := types.ListValueMust(
		NetworkInterfacesType{
			basetypes.ObjectType{
				AttrTypes: NetworkInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.NetworkInterfaces.Elements(),
	)

	if v.NetworkInterfaces.IsNull() {
		networkInterfaces = types.ListNull(
			NetworkInterfacesType{
				basetypes.ObjectType{
					AttrTypes: NetworkInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NetworkInterfaces.IsUnknown() {
		networkInterfaces = types.ListUnknown(
			NetworkInterfacesType{
				basetypes.ObjectType{
					AttrTypes: NetworkInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var scaleToZero basetypes.ObjectValue

	if v.ScaleToZero.IsNull() {
		scaleToZero = types.ObjectNull(
			ScaleToZeroValue{}.AttributeTypes(ctx),
		)
	}

	if v.ScaleToZero.IsUnknown() {
		scaleToZero = types.ObjectUnknown(
			ScaleToZeroValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ScaleToZero.IsNull() && !v.ScaleToZero.IsUnknown() {
		scaleToZero = types.ObjectValueMust(
			ScaleToZeroValue{}.AttributeTypes(ctx),
			v.ScaleToZero.Attributes(),
		)
	}

	var serviceGroup basetypes.ObjectValue

	if v.ServiceGroup.IsNull() {
		serviceGroup = types.ObjectNull(
			ServiceGroupValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServiceGroup.IsUnknown() {
		serviceGroup = types.ObjectUnknown(
			ServiceGroupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServiceGroup.IsNull() && !v.ServiceGroup.IsUnknown() {
		serviceGroup = types.ObjectValueMust(
			ServiceGroupValue{}.AttributeTypes(ctx),
			v.ServiceGroup.Attributes(),
		)
	}

	volumes := types.ListValueMust(
		VolumesType{
			basetypes.ObjectType{
				AttrTypes: VolumesValue{}.AttributeTypes(ctx),
			},
		},
		v.Volumes.Elements(),
	)

	if v.Volumes.IsNull() {
		volumes = types.ListNull(
			VolumesType{
				basetypes.ObjectType{
					AttrTypes: VolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Volumes.IsUnknown() {
		volumes = types.ListUnknown(
			VolumesType{
				basetypes.ObjectType{
					AttrTypes: VolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var argsVal basetypes.ListValue
	switch {
	case v.Args.IsUnknown():
		argsVal = types.ListUnknown(types.StringType)
	case v.Args.IsNull():
		argsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		argsVal, d = types.ListValue(types.StringType, v.Args.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"args": basetypes.ListType{
				ElemType: types.StringType,
			},
			"boot_time_us": basetypes.Int64Type{},
			"created_at":   basetypes.StringType{},
			"exit_code":    basetypes.Int64Type{},
			"image":        basetypes.StringType{},
			"memory_mb":    basetypes.Int64Type{},
			"name":         basetypes.StringType{},
			"net_time_us":  basetypes.Int64Type{},
			"network_interfaces": basetypes.ListType{
				ElemType: NetworkInterfacesValue{}.Type(ctx),
			},
			"private_fqdn":   basetypes.StringType{},
			"restart_policy": basetypes.StringType{},
			"scale_to_zero": basetypes.ObjectType{
				AttrTypes: ScaleToZeroValue{}.AttributeTypes(ctx),
			},
			"service_group": basetypes.ObjectType{
				AttrTypes: ServiceGroupValue{}.AttributeTypes(ctx),
			},
			"start_count":       basetypes.Int64Type{},
			"started_at":        basetypes.StringType{},
			"state":             basetypes.StringType{},
			"stop_code":         basetypes.Int64Type{},
			"stop_reason":       basetypes.Int64Type{},
			"stopped_at":        basetypes.StringType{},
			"uptime_ms":         basetypes.Int64Type{},
			"uuid":              basetypes.StringType{},
			"vcpus":             basetypes.Int64Type{},
			"vmm_load_time_us":  basetypes.Int64Type{},
			"vmm_ready_time_us": basetypes.Int64Type{},
			"vmm_start_time_us": basetypes.Int64Type{},
			"volumes": basetypes.ListType{
				ElemType: VolumesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"args": basetypes.ListType{
			ElemType: types.StringType,
		},
		"boot_time_us": basetypes.Int64Type{},
		"created_at":   basetypes.StringType{},
		"exit_code":    basetypes.Int64Type{},
		"image":        basetypes.StringType{},
		"memory_mb":    basetypes.Int64Type{},
		"name":         basetypes.StringType{},
		"net_time_us":  basetypes.Int64Type{},
		"network_interfaces": basetypes.ListType{
			ElemType: NetworkInterfacesValue{}.Type(ctx),
		},
		"private_fqdn":   basetypes.StringType{},
		"restart_policy": basetypes.StringType{},
		"scale_to_zero": basetypes.ObjectType{
			AttrTypes: ScaleToZeroValue{}.AttributeTypes(ctx),
		},
		"service_group": basetypes.ObjectType{
			AttrTypes: ServiceGroupValue{}.AttributeTypes(ctx),
		},
		"start_count":       basetypes.Int64Type{},
		"started_at":        basetypes.StringType{},
		"state":             basetypes.StringType{},
		"stop_code":         basetypes.Int64Type{},
		"stop_reason":       basetypes.Int64Type{},
		"stopped_at":        basetypes.StringType{},
		"uptime_ms":         basetypes.Int64Type{},
		"uuid":              basetypes.StringType{},
		"vcpus":             basetypes.Int64Type{},
		"vmm_load_time_us":  basetypes.Int64Type{},
		"vmm_ready_time_us": basetypes.Int64Type{},
		"vmm_start_time_us": basetypes.Int64Type{},
		"volumes": basetypes.ListType{
			ElemType: VolumesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"args":               argsVal,
			"boot_time_us":       v.BootTimeUs,
			"created_at":         v.CreatedAt,
			"exit_code":          v.ExitCode,
			"image":              v.Image,
			"memory_mb":          v.MemoryMb,
			"name":               v.Name,
			"net_time_us":        v.NetTimeUs,
			"network_interfaces": networkInterfaces,
			"private_fqdn":       v.PrivateFqdn,
			"restart_policy":     v.RestartPolicy,
			"scale_to_zero":      scaleToZero,
			"service_group":      serviceGroup,
			"start_count":        v.StartCount,
			"started_at":         v.StartedAt,
			"state":              v.State,
			"stop_code":          v.StopCode,
			"stop_reason":        v.StopReason,
			"stopped_at":         v.StoppedAt,
			"uptime_ms":          v.UptimeMs,
			"uuid":               v.Uuid,
			"vcpus":              v.Vcpus,
			"vmm_load_time_us":   v.VmmLoadTimeUs,
			"vmm_ready_time_us":  v.VmmReadyTimeUs,
			"vmm_start_time_us":  v.VmmStartTimeUs,
			"volumes":            volumes,
		})

	return objVal, diags
}

func (v InstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(InstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Args.Equal(other.Args) {
		return false
	}

	if !v.BootTimeUs.Equal(other.BootTimeUs) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.ExitCode.Equal(other.ExitCode) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.MemoryMb.Equal(other.MemoryMb) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NetTimeUs.Equal(other.NetTimeUs) {
		return false
	}

	if !v.NetworkInterfaces.Equal(other.NetworkInterfaces) {
		return false
	}

	if !v.PrivateFqdn.Equal(other.PrivateFqdn) {
		return false
	}

	if !v.RestartPolicy.Equal(other.RestartPolicy) {
		return false
	}

	if !v.ScaleToZero.Equal(other.ScaleToZero) {
		return false
	}

	if !v.ServiceGroup.Equal(other.ServiceGroup) {
		return false
	}

	if !v.StartCount.Equal(other.StartCount) {
		return false
	}

	if !v.StartedAt.Equal(other.StartedAt) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.StopCode.Equal(other.StopCode) {
		return false
	}

	if !v.StopReason.Equal(other.StopReason) {
		return false
	}

	if !v.StoppedAt.Equal(other.StoppedAt) {
		return false
	}

	if !v.UptimeMs.Equal(other.UptimeMs) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	if !v.VmmLoadTimeUs.Equal(other.VmmLoadTimeUs) {
		return false
	}

	if !v.VmmReadyTimeUs.Equal(other.VmmReadyTimeUs) {
		return false
	}

	if !v.VmmStartTimeUs.Equal(other.VmmStartTimeUs) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v InstancesValue) Type(ctx context.Context) attr.Type {
	return InstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"args": basetypes.ListType{
			ElemType: types.StringType,
		},
		"boot_time_us": basetypes.Int64Type{},
		"created_at":   basetypes.StringType{},
		"exit_code":    basetypes.Int64Type{},
		"image":        basetypes.StringType{},
		"memory_mb":    basetypes.Int64Type{},
		"name":         basetypes.StringType{},
		"net_time_us":  basetypes.Int64Type{},
		"network_interfaces": basetypes.ListType{
			ElemType: NetworkInterfacesValue{}.Type(ctx),
		},
		"private_fqdn":   basetypes.StringType{},
		"restart_policy": basetypes.StringType{},
		"scale_to_zero": basetypes.ObjectType{
			AttrTypes: ScaleToZeroValue{}.AttributeTypes(ctx),
		},
		"service_group": basetypes.ObjectType{
			AttrTypes: ServiceGroupValue{}.AttributeTypes(ctx),
		},
		"start_count":       basetypes.Int64Type{},
		"started_at":        basetypes.StringType{},
		"state":             basetypes.StringType{},
		"stop_code":         basetypes.Int64Type{},
		"stop_reason":       basetypes.Int64Type{},
		"stopped_at":        basetypes.StringType{},
		"uptime_ms":         basetypes.Int64Type{},
		"uuid":              basetypes.StringType{},
		"vcpus":             basetypes.Int64Type{},
		"vmm_load_time_us":  basetypes.Int64Type{},
		"vmm_ready_time_us": basetypes.Int64Type{},
		"vmm_start_time_us": basetypes.Int64Type{},
		"volumes": basetypes.ListType{
			ElemType: VolumesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = NetworkInterfacesType{}

type NetworkInterfacesType struct {
	basetypes.ObjectType
}

func (t NetworkInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkInterfacesType) String() string {
	return "NetworkInterfacesType"
}

func (t NetworkInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return nil, diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPacketsAttribute, ok := attributes["rx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_packets is missing from object`)

		return nil, diags
	}

	rxPacketsVal, ok := rxPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_packets expected to be basetypes.Int64Value, was: %T`, rxPacketsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPacketsAttribute, ok := attributes["tx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_packets is missing from object`)

		return nil, diags
	}

	txPacketsVal, ok := txPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_packets expected to be basetypes.Int64Value, was: %T`, txPacketsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkInterfacesValue{
		Mac:       macVal,
		PrivateIp: privateIpVal,
		RxBytes:   rxBytesVal,
		RxPackets: rxPacketsVal,
		TxBytes:   txBytesVal,
		TxPackets: txPacketsVal,
		Uuid:      uuidVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNetworkInterfacesValueNull() NetworkInterfacesValue {
	return NetworkInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkInterfacesValueUnknown() NetworkInterfacesValue {
	return NetworkInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkInterfacesValue Attribute Value",
				"While creating a NetworkInterfacesValue value, a missing attribute value was detected. "+
					"A NetworkInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkInterfacesValue Attribute Type",
				"While creating a NetworkInterfacesValue value, an invalid attribute value was detected. "+
					"A NetworkInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkInterfacesValue Attribute Value",
				"While creating a NetworkInterfacesValue value, an extra attribute value was detected. "+
					"A NetworkInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkInterfacesValueUnknown(), diags
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	privateIpAttribute, ok := attributes["private_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_ip is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	privateIpVal, ok := privateIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_ip expected to be basetypes.StringValue, was: %T`, privateIpAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPacketsAttribute, ok := attributes["rx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_packets is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	rxPacketsVal, ok := rxPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_packets expected to be basetypes.Int64Value, was: %T`, rxPacketsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPacketsAttribute, ok := attributes["tx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_packets is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	txPacketsVal, ok := txPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_packets expected to be basetypes.Int64Value, was: %T`, txPacketsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewNetworkInterfacesValueUnknown(), diags
	}

	return NetworkInterfacesValue{
		Mac:       macVal,
		PrivateIp: privateIpVal,
		RxBytes:   rxBytesVal,
		RxPackets: rxPacketsVal,
		TxBytes:   txBytesVal,
		TxPackets: txPacketsVal,
		Uuid:      uuidVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewNetworkInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkInterfacesValue {
	object, diags := NewNetworkInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkInterfacesValueMust(NetworkInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkInterfacesType) ValueType(ctx context.Context) attr.Value {
	return NetworkInterfacesValue{}
}

var _ basetypes.ObjectValuable = NetworkInterfacesValue{}

type NetworkInterfacesValue struct {
	Mac       basetypes.StringValue `tfsdk:"mac"`
	PrivateIp basetypes.StringValue `tfsdk:"private_ip"`
	RxBytes   basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPackets basetypes.Int64Value  `tfsdk:"rx_packets"`
	TxBytes   basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPackets basetypes.Int64Value  `tfsdk:"tx_packets"`
	Uuid      basetypes.StringValue `tfsdk:"uuid"`
	state     attr.ValueState
}

func (v NetworkInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["private_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_packets"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_packets"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.PrivateIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_ip"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPackets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_packets"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPackets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_packets"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkInterfacesValue) String() string {
	return "NetworkInterfacesValue"
}

func (v NetworkInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mac":        basetypes.StringType{},
		"private_ip": basetypes.StringType{},
		"rx_bytes":   basetypes.Int64Type{},
		"rx_packets": basetypes.Int64Type{},
		"tx_bytes":   basetypes.Int64Type{},
		"tx_packets": basetypes.Int64Type{},
		"uuid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mac":        v.Mac,
			"private_ip": v.PrivateIp,
			"rx_bytes":   v.RxBytes,
			"rx_packets": v.RxPackets,
			"tx_bytes":   v.TxBytes,
			"tx_packets": v.TxPackets,
			"uuid":       v.Uuid,
		})

	return objVal, diags
}

func (v NetworkInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.PrivateIp.Equal(other.PrivateIp) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPackets.Equal(other.RxPackets) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPackets.Equal(other.TxPackets) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v NetworkInterfacesValue) Type(ctx context.Context) attr.Type {
	return NetworkInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mac":        basetypes.StringType{},
		"private_ip": basetypes.StringType{},
		"rx_bytes":   basetypes.Int64Type{},
		"rx_packets": basetypes.Int64Type{},
		"tx_bytes":   basetypes.Int64Type{},
		"tx_packets": basetypes.Int64Type{},
		"uuid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ScaleToZeroType{}

type ScaleToZeroType struct {
	basetypes.ObjectType
}

func (t ScaleToZeroType) Equal(o attr.Type) bool {
	other, ok := o.(ScaleToZeroType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScaleToZeroType) String() string {
	return "ScaleToZeroType"
}

func (t ScaleToZeroType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cooldownTimeMsAttribute, ok := attributes["cooldown_time_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown_time_ms is missing from object`)

		return nil, diags
	}

	cooldownTimeMsVal, ok := cooldownTimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown_time_ms expected to be basetypes.Int64Value, was: %T`, cooldownTimeMsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return nil, diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	statefulAttribute, ok := attributes["stateful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stateful is missing from object`)

		return nil, diags
	}

	statefulVal, ok := statefulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stateful expected to be basetypes.BoolValue, was: %T`, statefulAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScaleToZeroValue{
		CooldownTimeMs: cooldownTimeMsVal,
		Enabled:        enabledVal,
		Policy:         policyVal,
		Stateful:       statefulVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewScaleToZeroValueNull() ScaleToZeroValue {
	return ScaleToZeroValue{
		state: attr.ValueStateNull,
	}
}

func NewScaleToZeroValueUnknown() ScaleToZeroValue {
	return ScaleToZeroValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScaleToZeroValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScaleToZeroValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScaleToZeroValue Attribute Value",
				"While creating a ScaleToZeroValue value, a missing attribute value was detected. "+
					"A ScaleToZeroValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScaleToZeroValue Attribute Type",
				"While creating a ScaleToZeroValue value, an invalid attribute value was detected. "+
					"A ScaleToZeroValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScaleToZeroValue Attribute Value",
				"While creating a ScaleToZeroValue value, an extra attribute value was detected. "+
					"A ScaleToZeroValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScaleToZeroValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScaleToZeroValueUnknown(), diags
	}

	cooldownTimeMsAttribute, ok := attributes["cooldown_time_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown_time_ms is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	cooldownTimeMsVal, ok := cooldownTimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown_time_ms expected to be basetypes.Int64Value, was: %T`, cooldownTimeMsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	statefulAttribute, ok := attributes["stateful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stateful is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	statefulVal, ok := statefulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stateful expected to be basetypes.BoolValue, was: %T`, statefulAttribute))
	}

	if diags.HasError() {
		return NewScaleToZeroValueUnknown(), diags
	}

	return ScaleToZeroValue{
		CooldownTimeMs: cooldownTimeMsVal,
		Enabled:        enabledVal,
		Policy:         policyVal,
		Stateful:       statefulVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewScaleToZeroValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScaleToZeroValue {
	object, diags := NewScaleToZeroValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScaleToZeroValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScaleToZeroType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScaleToZeroValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScaleToZeroValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScaleToZeroValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScaleToZeroValueMust(ScaleToZeroValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScaleToZeroType) ValueType(ctx context.Context) attr.Value {
	return ScaleToZeroValue{}
}

var _ basetypes.ObjectValuable = ScaleToZeroValue{}

type ScaleToZeroValue struct {
	CooldownTimeMs basetypes.Int64Value  `tfsdk:"cooldown_time_ms"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	Policy         basetypes.StringValue `tfsdk:"policy"`
	Stateful       basetypes.BoolValue   `tfsdk:"stateful"`
	state          attr.ValueState
}

func (v ScaleToZeroValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cooldown_time_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stateful"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CooldownTimeMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cooldown_time_ms"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Policy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy"] = val

		val, err = v.Stateful.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stateful"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScaleToZeroValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScaleToZeroValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScaleToZeroValue) String() string {
	return "ScaleToZeroValue"
}

func (v ScaleToZeroValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cooldown_time_ms": basetypes.Int64Type{},
		"enabled":          basetypes.BoolType{},
		"policy":           basetypes.StringType{},
		"stateful":         basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cooldown_time_ms": v.CooldownTimeMs,
			"enabled":          v.Enabled,
			"policy":           v.Policy,
			"stateful":         v.Stateful,
		})

	return objVal, diags
}

func (v ScaleToZeroValue) Equal(o attr.Value) bool {
	other, ok := o.(ScaleToZeroValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CooldownTimeMs.Equal(other.CooldownTimeMs) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Policy.Equal(other.Policy) {
		return false
	}

	if !v.Stateful.Equal(other.Stateful) {
		return false
	}

	return true
}

func (v ScaleToZeroValue) Type(ctx context.Context) attr.Type {
	return ScaleToZeroType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScaleToZeroValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cooldown_time_ms": basetypes.Int64Type{},
		"enabled":          basetypes.BoolType{},
		"policy":           basetypes.StringType{},
		"stateful":         basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServiceGroupType{}

type ServiceGroupType struct {
	basetypes.ObjectType
}

func (t ServiceGroupType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceGroupType) String() string {
	return "ServiceGroupType"
}

func (t ServiceGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return nil, diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceGroupValue{
		Domains: domainsVal,
		Name:    nameVal,
		Uuid:    uuidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupValueNull() ServiceGroupValue {
	return ServiceGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceGroupValueUnknown() ServiceGroupValue {
	return ServiceGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceGroupValue Attribute Value",
				"While creating a ServiceGroupValue value, a missing attribute value was detected. "+
					"A ServiceGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceGroupValue Attribute Type",
				"While creating a ServiceGroupValue value, an invalid attribute value was detected. "+
					"A ServiceGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceGroupValue Attribute Value",
				"While creating a ServiceGroupValue value, an extra attribute value was detected. "+
					"A ServiceGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceGroupValueUnknown(), diags
	}

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewServiceGroupValueUnknown(), diags
	}

	return ServiceGroupValue{
		Domains: domainsVal,
		Name:    nameVal,
		Uuid:    uuidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceGroupValue {
	object, diags := NewServiceGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceGroupValueMust(ServiceGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceGroupType) ValueType(ctx context.Context) attr.Value {
	return ServiceGroupValue{}
}

var _ basetypes.ObjectValuable = ServiceGroupValue{}

type ServiceGroupValue struct {
	Domains basetypes.ListValue   `tfsdk:"domains"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Uuid    basetypes.StringValue `tfsdk:"uuid"`
	state   attr.ValueState
}

func (v ServiceGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["domains"] = basetypes.ListType{
		ElemType: DomainsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Domains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domains"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceGroupValue) String() string {
	return "ServiceGroupValue"
}

func (v ServiceGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	domains := types.ListValueMust(
		DomainsType{
			basetypes.ObjectType{
				AttrTypes: DomainsValue{}.AttributeTypes(ctx),
			},
		},
		v.Domains.Elements(),
	)

	if v.Domains.IsNull() {
		domains = types.ListNull(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Domains.IsUnknown() {
		domains = types.ListUnknown(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"domains": domains,
			"name":    v.Name,
			"uuid":    v.Uuid,
		})

	return objVal, diags
}

func (v ServiceGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Domains.Equal(other.Domains) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ServiceGroupValue) Type(ctx context.Context) attr.Type {
	return ServiceGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DomainsType{}

type DomainsType struct {
	basetypes.ObjectType
}

func (t DomainsType) Equal(o attr.Type) bool {
	other, ok := o.(DomainsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DomainsType) String() string {
	return "DomainsType"
}

func (t DomainsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return nil, diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	fqdnAttribute, ok := attributes["fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fqdn is missing from object`)

		return nil, diags
	}

	fqdnVal, ok := fqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fqdn expected to be basetypes.StringValue, was: %T`, fqdnAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Fqdn:        fqdnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueNull() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateNull,
	}
}

func NewDomainsValueUnknown() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDomainsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DomainsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DomainsValue Attribute Value",
				"While creating a DomainsValue value, a missing attribute value was detected. "+
					"A DomainsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DomainsValue Attribute Type",
				"While creating a DomainsValue value, an invalid attribute value was detected. "+
					"A DomainsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DomainsValue Attribute Value",
				"While creating a DomainsValue value, an extra attribute value was detected. "+
					"A DomainsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DomainsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	fqdnAttribute, ok := attributes["fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fqdn is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	fqdnVal, ok := fqdnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fqdn expected to be basetypes.StringValue, was: %T`, fqdnAttribute))
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Fqdn:        fqdnVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DomainsValue {
	object, diags := NewDomainsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDomainsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DomainsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDomainsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDomainsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDomainsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDomainsValueMust(DomainsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DomainsType) ValueType(ctx context.Context) attr.Value {
	return DomainsValue{}
}

var _ basetypes.ObjectValuable = DomainsValue{}

type DomainsValue struct {
	Certificate basetypes.ObjectValue `tfsdk:"certificate"`
	Fqdn        basetypes.StringValue `tfsdk:"fqdn"`
	state       attr.ValueState
}

func (v DomainsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["certificate"] = basetypes.ObjectType{
		AttrTypes: CertificateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["fqdn"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Certificate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certificate"] = val

		val, err = v.Fqdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fqdn"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DomainsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DomainsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DomainsValue) String() string {
	return "DomainsValue"
}

func (v DomainsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var certificate basetypes.ObjectValue

	if v.Certificate.IsNull() {
		certificate = types.ObjectNull(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Certificate.IsUnknown() {
		certificate = types.ObjectUnknown(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Certificate.IsNull() && !v.Certificate.IsUnknown() {
		certificate = types.ObjectValueMust(
			CertificateValue{}.AttributeTypes(ctx),
			v.Certificate.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"fqdn": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certificate": certificate,
			"fqdn":        v.Fqdn,
		})

	return objVal, diags
}

func (v DomainsValue) Equal(o attr.Value) bool {
	other, ok := o.(DomainsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Certificate.Equal(other.Certificate) {
		return false
	}

	if !v.Fqdn.Equal(other.Fqdn) {
		return false
	}

	return true
}

func (v DomainsValue) Type(ctx context.Context) attr.Type {
	return DomainsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DomainsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"fqdn": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CertificateType{}

type CertificateType struct {
	basetypes.ObjectType
}

func (t CertificateType) Equal(o attr.Type) bool {
	other, ok := o.(CertificateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CertificateType) String() string {
	return "CertificateType"
}

func (t CertificateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CertificateValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueNull() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateNull,
	}
}

func NewCertificateValueUnknown() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCertificateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CertificateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CertificateValue Attribute Value",
				"While creating a CertificateValue value, a missing attribute value was detected. "+
					"A CertificateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CertificateValue Attribute Type",
				"While creating a CertificateValue value, an invalid attribute value was detected. "+
					"A CertificateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CertificateValue Attribute Value",
				"While creating a CertificateValue value, an extra attribute value was detected. "+
					"A CertificateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CertificateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	return CertificateValue{
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CertificateValue {
	object, diags := NewCertificateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCertificateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CertificateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCertificateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCertificateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCertificateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCertificateValueMust(CertificateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CertificateType) ValueType(ctx context.Context) attr.Value {
	return CertificateValue{}
}

var _ basetypes.ObjectValuable = CertificateValue{}

type CertificateValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v CertificateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CertificateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CertificateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CertificateValue) String() string {
	return "CertificateValue"
}

func (v CertificateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
		})

	return objVal, diags
}

func (v CertificateValue) Equal(o attr.Value) bool {
	other, ok := o.(CertificateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v CertificateValue) Type(ctx context.Context) attr.Type {
	return CertificateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CertificateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesType{}

type VolumesType struct {
	basetypes.ObjectType
}

func (t VolumesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesType) String() string {
	return "VolumesType"
}

func (t VolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	atAttribute, ok := attributes["at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`at is missing from object`)

		return nil, diags
	}

	atVal, ok := atAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`at expected to be basetypes.StringValue, was: %T`, atAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return nil, diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesValue{
		At:       atVal,
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueNull() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesValueUnknown() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesValue Attribute Value",
				"While creating a VolumesValue value, a missing attribute value was detected. "+
					"A VolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesValue Attribute Type",
				"While creating a VolumesValue value, an invalid attribute value was detected. "+
					"A VolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesValue Attribute Value",
				"While creating a VolumesValue value, an extra attribute value was detected. "+
					"A VolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	atAttribute, ok := attributes["at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`at is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	atVal, ok := atAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`at expected to be basetypes.StringValue, was: %T`, atAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	return VolumesValue{
		At:       atVal,
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesValue {
	object, diags := NewVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesValueMust(VolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesType) ValueType(ctx context.Context) attr.Value {
	return VolumesValue{}
}

var _ basetypes.ObjectValuable = VolumesValue{}

type VolumesValue struct {
	At       basetypes.StringValue `tfsdk:"at"`
	Name     basetypes.StringValue `tfsdk:"name"`
	ReadOnly basetypes.BoolValue   `tfsdk:"read_only"`
	Uuid     basetypes.StringValue `tfsdk:"uuid"`
	state    attr.ValueState
}

func (v VolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.At.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["at"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ReadOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read_only"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesValue) String() string {
	return "VolumesValue"
}

func (v VolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"at":        basetypes.StringType{},
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"uuid":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"at":        v.At,
			"name":      v.Name,
			"read_only": v.ReadOnly,
			"uuid":      v.Uuid,
		})

	return objVal, diags
}

func (v VolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.At.Equal(other.At) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ReadOnly.Equal(other.ReadOnly) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v VolumesValue) Type(ctx context.Context) attr.Type {
	return VolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"at":        basetypes.StringType{},
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"uuid":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ScaleToZeroType{}

type ScaleToZeroType struct {
	basetypes.ObjectType
}

func (t ScaleToZeroType) Equal(o attr.Type) bool {
	other, ok := o.(ScaleToZeroType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScaleToZeroType) String() string {
	return "ScaleToZeroType"
}

func (t ScaleToZeroType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cooldownTimeMsAttribute, ok := attributes["cooldown_time_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown_time_ms is missing from object`)

		return nil, diags
	}

	cooldownTimeMsVal, ok := cooldownTimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown_time_ms expected to be basetypes.Int64Value, was: %T`, cooldownTimeMsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return nil, diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	statefulAttribute, ok := attributes["stateful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stateful is missing from object`)

		return nil, diags
	}

	statefulVal, ok := statefulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stateful expected to be basetypes.BoolValue, was: %T`, statefulAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScaleToZeroValue{
		CooldownTimeMs: cooldownTimeMsVal,
		Enabled:        enabledVal,
		Policy:         policyVal,
		Stateful:       statefulVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewScaleToZeroValueNull() ScaleToZeroValue {
	return ScaleToZeroValue{
		state: attr.ValueStateNull,
	}
}

func NewScaleToZeroValueUnknown() ScaleToZeroValue {
	return ScaleToZeroValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScaleToZeroValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScaleToZeroValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScaleToZeroValue Attribute Value",
				"While creating a ScaleToZeroValue value, a missing attribute value was detected. "+
					"A ScaleToZeroValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScaleToZeroValue Attribute Type",
				"While creating a ScaleToZeroValue value, an invalid attribute value was detected. "+
					"A ScaleToZeroValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScaleToZeroValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScaleToZeroValue Attribute Value",
				"While creating a ScaleToZeroValue value, an extra attribute value was detected. "+
					"A ScaleToZeroValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScaleToZeroValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScaleToZeroValueUnknown(), diags
	}

	cooldownTimeMsAttribute, ok := attributes["cooldown_time_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cooldown_time_ms is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	cooldownTimeMsVal, ok := cooldownTimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cooldown_time_ms expected to be basetypes.Int64Value, was: %T`, cooldownTimeMsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	statefulAttribute, ok := attributes["stateful"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stateful is missing from object`)

		return NewScaleToZeroValueUnknown(), diags
	}

	statefulVal, ok := statefulAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stateful expected to be basetypes.BoolValue, was: %T`, statefulAttribute))
	}

	if diags.HasError() {
		return NewScaleToZeroValueUnknown(), diags
	}

	return ScaleToZeroValue{
		CooldownTimeMs: cooldownTimeMsVal,
		Enabled:        enabledVal,
		Policy:         policyVal,
		Stateful:       statefulVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewScaleToZeroValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScaleToZeroValue {
	object, diags := NewScaleToZeroValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScaleToZeroValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScaleToZeroType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScaleToZeroValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScaleToZeroValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScaleToZeroValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScaleToZeroValueMust(ScaleToZeroValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScaleToZeroType) ValueType(ctx context.Context) attr.Value {
	return ScaleToZeroValue{}
}

var _ basetypes.ObjectValuable = ScaleToZeroValue{}

type ScaleToZeroValue struct {
	CooldownTimeMs basetypes.Int64Value  `tfsdk:"cooldown_time_ms"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	Policy         basetypes.StringValue `tfsdk:"policy"`
	Stateful       basetypes.BoolValue   `tfsdk:"stateful"`
	state          attr.ValueState
}

func (v ScaleToZeroValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cooldown_time_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stateful"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CooldownTimeMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cooldown_time_ms"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Policy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy"] = val

		val, err = v.Stateful.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stateful"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScaleToZeroValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScaleToZeroValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScaleToZeroValue) String() string {
	return "ScaleToZeroValue"
}

func (v ScaleToZeroValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cooldown_time_ms": basetypes.Int64Type{},
		"enabled":          basetypes.BoolType{},
		"policy":           basetypes.StringType{},
		"stateful":         basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cooldown_time_ms": v.CooldownTimeMs,
			"enabled":          v.Enabled,
			"policy":           v.Policy,
			"stateful":         v.Stateful,
		})

	return objVal, diags
}

func (v ScaleToZeroValue) Equal(o attr.Value) bool {
	other, ok := o.(ScaleToZeroValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CooldownTimeMs.Equal(other.CooldownTimeMs) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Policy.Equal(other.Policy) {
		return false
	}

	if !v.Stateful.Equal(other.Stateful) {
		return false
	}

	return true
}

func (v ScaleToZeroValue) Type(ctx context.Context) attr.Type {
	return ScaleToZeroType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScaleToZeroValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cooldown_time_ms": basetypes.Int64Type{},
		"enabled":          basetypes.BoolType{},
		"policy":           basetypes.StringType{},
		"stateful":         basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServiceGroupType{}

type ServiceGroupType struct {
	basetypes.ObjectType
}

func (t ServiceGroupType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceGroupType) String() string {
	return "ServiceGroupType"
}

func (t ServiceGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return nil, diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceGroupValue{
		Domains: domainsVal,
		Name:    nameVal,
		Uuid:    uuidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupValueNull() ServiceGroupValue {
	return ServiceGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceGroupValueUnknown() ServiceGroupValue {
	return ServiceGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceGroupValue Attribute Value",
				"While creating a ServiceGroupValue value, a missing attribute value was detected. "+
					"A ServiceGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceGroupValue Attribute Type",
				"While creating a ServiceGroupValue value, an invalid attribute value was detected. "+
					"A ServiceGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceGroupValue Attribute Value",
				"While creating a ServiceGroupValue value, an extra attribute value was detected. "+
					"A ServiceGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceGroupValueUnknown(), diags
	}

	domainsAttribute, ok := attributes["domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domains is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	domainsVal, ok := domainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domains expected to be basetypes.ListValue, was: %T`, domainsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewServiceGroupValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewServiceGroupValueUnknown(), diags
	}

	return ServiceGroupValue{
		Domains: domainsVal,
		Name:    nameVal,
		Uuid:    uuidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewServiceGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceGroupValue {
	object, diags := NewServiceGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceGroupValueMust(ServiceGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceGroupType) ValueType(ctx context.Context) attr.Value {
	return ServiceGroupValue{}
}

var _ basetypes.ObjectValuable = ServiceGroupValue{}

type ServiceGroupValue struct {
	Domains basetypes.ListValue   `tfsdk:"domains"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Uuid    basetypes.StringValue `tfsdk:"uuid"`
	state   attr.ValueState
}

func (v ServiceGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["domains"] = basetypes.ListType{
		ElemType: DomainsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Domains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domains"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceGroupValue) String() string {
	return "ServiceGroupValue"
}

func (v ServiceGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	domains := types.ListValueMust(
		DomainsType{
			basetypes.ObjectType{
				AttrTypes: DomainsValue{}.AttributeTypes(ctx),
			},
		},
		v.Domains.Elements(),
	)

	if v.Domains.IsNull() {
		domains = types.ListNull(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Domains.IsUnknown() {
		domains = types.ListUnknown(
			DomainsType{
				basetypes.ObjectType{
					AttrTypes: DomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"domains": domains,
			"name":    v.Name,
			"uuid":    v.Uuid,
		})

	return objVal, diags
}

func (v ServiceGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Domains.Equal(other.Domains) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ServiceGroupValue) Type(ctx context.Context) attr.Type {
	return ServiceGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"domains": basetypes.ListType{
			ElemType: DomainsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DomainsType{}

type DomainsType struct {
	basetypes.ObjectType
}

func (t DomainsType) Equal(o attr.Type) bool {
	other, ok := o.(DomainsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DomainsType) String() string {
	return "DomainsType"
}

func (t DomainsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return nil, diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueNull() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateNull,
	}
}

func NewDomainsValueUnknown() DomainsValue {
	return DomainsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDomainsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DomainsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DomainsValue Attribute Value",
				"While creating a DomainsValue value, a missing attribute value was detected. "+
					"A DomainsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DomainsValue Attribute Type",
				"While creating a DomainsValue value, an invalid attribute value was detected. "+
					"A DomainsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DomainsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DomainsValue Attribute Value",
				"While creating a DomainsValue value, an extra attribute value was detected. "+
					"A DomainsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DomainsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	certificateAttribute, ok := attributes["certificate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`certificate is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	certificateVal, ok := certificateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`certificate expected to be basetypes.ObjectValue, was: %T`, certificateAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDomainsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewDomainsValueUnknown(), diags
	}

	return DomainsValue{
		Certificate: certificateVal,
		Name:        nameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDomainsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DomainsValue {
	object, diags := NewDomainsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDomainsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DomainsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDomainsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDomainsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDomainsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDomainsValueMust(DomainsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DomainsType) ValueType(ctx context.Context) attr.Value {
	return DomainsValue{}
}

var _ basetypes.ObjectValuable = DomainsValue{}

type DomainsValue struct {
	Certificate basetypes.ObjectValue `tfsdk:"certificate"`
	Name        basetypes.StringValue `tfsdk:"name"`
	state       attr.ValueState
}

func (v DomainsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["certificate"] = basetypes.ObjectType{
		AttrTypes: CertificateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Certificate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["certificate"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DomainsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DomainsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DomainsValue) String() string {
	return "DomainsValue"
}

func (v DomainsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var certificate basetypes.ObjectValue

	if v.Certificate.IsNull() {
		certificate = types.ObjectNull(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Certificate.IsUnknown() {
		certificate = types.ObjectUnknown(
			CertificateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Certificate.IsNull() && !v.Certificate.IsUnknown() {
		certificate = types.ObjectValueMust(
			CertificateValue{}.AttributeTypes(ctx),
			v.Certificate.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"certificate": certificate,
			"name":        v.Name,
		})

	return objVal, diags
}

func (v DomainsValue) Equal(o attr.Value) bool {
	other, ok := o.(DomainsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Certificate.Equal(other.Certificate) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v DomainsValue) Type(ctx context.Context) attr.Type {
	return DomainsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DomainsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"certificate": basetypes.ObjectType{
			AttrTypes: CertificateValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CertificateType{}

type CertificateType struct {
	basetypes.ObjectType
}

func (t CertificateType) Equal(o attr.Type) bool {
	other, ok := o.(CertificateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CertificateType) String() string {
	return "CertificateType"
}

func (t CertificateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CertificateValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueNull() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateNull,
	}
}

func NewCertificateValueUnknown() CertificateValue {
	return CertificateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCertificateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CertificateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CertificateValue Attribute Value",
				"While creating a CertificateValue value, a missing attribute value was detected. "+
					"A CertificateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CertificateValue Attribute Type",
				"While creating a CertificateValue value, an invalid attribute value was detected. "+
					"A CertificateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CertificateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CertificateValue Attribute Value",
				"While creating a CertificateValue value, an extra attribute value was detected. "+
					"A CertificateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CertificateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewCertificateValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewCertificateValueUnknown(), diags
	}

	return CertificateValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewCertificateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CertificateValue {
	object, diags := NewCertificateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCertificateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CertificateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCertificateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCertificateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCertificateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCertificateValueMust(CertificateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CertificateType) ValueType(ctx context.Context) attr.Value {
	return CertificateValue{}
}

var _ basetypes.ObjectValuable = CertificateValue{}

type CertificateValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v CertificateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CertificateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CertificateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CertificateValue) String() string {
	return "CertificateValue"
}

func (v CertificateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v CertificateValue) Equal(o attr.Value) bool {
	other, ok := o.(CertificateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v CertificateValue) Type(ctx context.Context) attr.Type {
	return CertificateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CertificateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesType{}

type VolumesType struct {
	basetypes.ObjectType
}

func (t VolumesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesType) String() string {
	return "VolumesType"
}

func (t VolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	atAttribute, ok := attributes["at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`at is missing from object`)

		return nil, diags
	}

	atVal, ok := atAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`at expected to be basetypes.StringValue, was: %T`, atAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return nil, diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	sizeMbAttribute, ok := attributes["size_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_mb is missing from object`)

		return nil, diags
	}

	sizeMbVal, ok := sizeMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_mb expected to be basetypes.Int64Value, was: %T`, sizeMbAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesValue{
		At:       atVal,
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		SizeMb:   sizeMbVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueNull() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesValueUnknown() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesValue Attribute Value",
				"While creating a VolumesValue value, a missing attribute value was detected. "+
					"A VolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesValue Attribute Type",
				"While creating a VolumesValue value, an invalid attribute value was detected. "+
					"A VolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesValue Attribute Value",
				"While creating a VolumesValue value, an extra attribute value was detected. "+
					"A VolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	atAttribute, ok := attributes["at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`at is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	atVal, ok := atAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`at expected to be basetypes.StringValue, was: %T`, atAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	sizeMbAttribute, ok := attributes["size_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_mb is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	sizeMbVal, ok := sizeMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_mb expected to be basetypes.Int64Value, was: %T`, sizeMbAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	return VolumesValue{
		At:       atVal,
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		SizeMb:   sizeMbVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesValue {
	object, diags := NewVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesValueMust(VolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesType) ValueType(ctx context.Context) attr.Value {
	return VolumesValue{}
}

var _ basetypes.ObjectValuable = VolumesValue{}

type VolumesValue struct {
	At       basetypes.StringValue `tfsdk:"at"`
	Name     basetypes.StringValue `tfsdk:"name"`
	ReadOnly basetypes.BoolValue   `tfsdk:"read_only"`
	SizeMb   basetypes.Int64Value  `tfsdk:"size_mb"`
	Uuid     basetypes.StringValue `tfsdk:"uuid"`
	state    attr.ValueState
}

func (v VolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["size_mb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.At.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["at"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ReadOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read_only"] = val

		val, err = v.SizeMb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_mb"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesValue) String() string {
	return "VolumesValue"
}

func (v VolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"at":        basetypes.StringType{},
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"size_mb":   basetypes.Int64Type{},
		"uuid":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"at":        v.At,
			"name":      v.Name,
			"read_only": v.ReadOnly,
			"size_mb":   v.SizeMb,
			"uuid":      v.Uuid,
		})

	return objVal, diags
}

func (v VolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.At.Equal(other.At) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ReadOnly.Equal(other.ReadOnly) {
		return false
	}

	if !v.SizeMb.Equal(other.SizeMb) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v VolumesValue) Type(ctx context.Context) attr.Type {
	return VolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"at":        basetypes.StringType{},
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"size_mb":   basetypes.Int64Type{},
		"uuid":      basetypes.StringType{},
	}
}
