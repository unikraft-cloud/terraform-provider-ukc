// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_volume

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func VolumeResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"volumes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"attached_to": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed:            true,
												Description:         "The name of the instance that the volume is attached to.",
												MarkdownDescription: "The name of the instance that the volume is attached to.",
											},
											"uuid": schema.StringAttribute{
												Computed:            true,
												Description:         "The UUID of the instance that the volume is attached to.",
												MarkdownDescription: "The UUID of the instance that the volume is attached to.",
											},
										},
										CustomType: AttachedToType{
											ObjectType: types.ObjectType{
												AttrTypes: AttachedToValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of instances that this volume is attached to.",
									MarkdownDescription: "List of instances that this volume is attached to.",
								},
								"created_at": schema.StringAttribute{
									Computed:            true,
									Description:         "The time the volume was created.",
									MarkdownDescription: "The time the volume was created.",
								},
								"mounted_by": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed:            true,
												Description:         "The name of the instance that the volume is mounted in.",
												MarkdownDescription: "The name of the instance that the volume is mounted in.",
											},
											"read_only": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether the volume is mounted read-only or read-write.",
												MarkdownDescription: "Whether the volume is mounted read-only or read-write.",
											},
											"uuid": schema.StringAttribute{
												Computed:            true,
												Description:         "The UUID of the instance that the volume is mounted in.",
												MarkdownDescription: "The UUID of the instance that the volume is mounted in.",
											},
										},
										CustomType: MountedByType{
											ObjectType: types.ObjectType{
												AttrTypes: MountedByValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of instances that have this volume mounted.",
									MarkdownDescription: "List of instances that have this volume mounted.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of the volume.\n\nThis is a human-readable name that can be used to identify the volume.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the volume in API calls.",
									MarkdownDescription: "The name of the volume.\n\nThis is a human-readable name that can be used to identify the volume.\nThe name must be unique within the context of your account.  The name can\nalso be used to identify the volume in API calls.",
								},
								"persistent": schema.BoolAttribute{
									Computed:            true,
									Description:         "Indicates if the volume will stay alive when the last instance is deleted\nthat this volume is attached to.",
									MarkdownDescription: "Indicates if the volume will stay alive when the last instance is deleted\nthat this volume is attached to.",
								},
								"size_mb": schema.Int64Attribute{
									Computed:            true,
									Description:         "The size of the volume in megabytes.",
									MarkdownDescription: "The size of the volume in megabytes.",
								},
								"state": schema.StringAttribute{
									Computed:            true,
									Description:         "Current state of the volume.",
									MarkdownDescription: "Current state of the volume.",
								},
								"uuid": schema.StringAttribute{
									Computed:            true,
									Description:         "The UUID of the volume.\n\nThis is a unique identifier for the volume that is generated when the\nvolume is created.  The UUID is used to reference the volume in\nAPI calls and can be used to identify the volume in all API calls that\nrequire an identifier.",
									MarkdownDescription: "The UUID of the volume.\n\nThis is a unique identifier for the volume that is generated when the\nvolume is created.  The UUID is used to reference the volume in\nAPI calls and can be used to identify the volume in all API calls that\nrequire an identifier.",
								},
							},
							CustomType: VolumesType{
								ObjectType: types.ObjectType{
									AttrTypes: VolumesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "The volume(s) which were retrieved by the request.",
						MarkdownDescription: "The volume(s) which were retrieved by the request.",
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"details": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to include details about the volume in the response.  By\ndefault this is set to true, meaning that all information about the\nvolume will be included in the response.  If set to false, only the\nbasic information about the volume will be included, such as its name\nand UUID.",
				MarkdownDescription: "Whether to include details about the volume in the response.  By\ndefault this is set to true, meaning that all information about the\nvolume will be included in the response.  If set to false, only the\nbasic information about the volume will be included, such as its name\nand UUID.",
			},
			"message": schema.StringAttribute{
				Computed:            true,
				Description:         "An optional message providing additional information about the response.",
				MarkdownDescription: "An optional message providing additional information about the response.",
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The name of the volume.\n\nThis is a human-readable name that can be used to identify the volume. The name must be unique within the context of your account. If no name is specified, a random name of the form `vol-X` is generated for you, where `X` is a 5-character long random alphanumeric suffix. The name can also be used to identify the volume in API calls.",
				MarkdownDescription: "The name of the volume.\n\nThis is a human-readable name that can be used to identify the volume. The name must be unique within the context of your account. If no name is specified, a random name of the form `vol-X` is generated for you, where `X` is a 5-character long random alphanumeric suffix. The name can also be used to identify the volume in API calls.",
			},
			"op_time_us": schema.Int64Attribute{
				Computed:            true,
				Description:         "The operation time in microseconds. This is the time it took to process\nthe request and generate the response.",
				MarkdownDescription: "The operation time in microseconds. This is the time it took to process\nthe request and generate the response.",
			},
			"size_mb": schema.Int64Attribute{
				Required:            true,
				Description:         "The size of the volume in megabytes.",
				MarkdownDescription: "The size of the volume in megabytes.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "The status of the response.",
				MarkdownDescription: "The status of the response.",
			},
		},
	}
}

type VolumeModel struct {
	Data     DataValue    `tfsdk:"data"`
	Details  types.Bool   `tfsdk:"details"`
	Message  types.String `tfsdk:"message"`
	Name     types.String `tfsdk:"name"`
	OpTimeUs types.Int64  `tfsdk:"op_time_us"`
	SizeMb   types.Int64  `tfsdk:"size_mb"`
	Status   types.String `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.ListValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Volumes: volumesVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewDataValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.ListValue, was: %T`, volumesAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Volumes: volumesVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Volumes basetypes.ListValue `tfsdk:"volumes"`
	state   attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["volumes"] = basetypes.ListType{
		ElemType: VolumesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	volumes := types.ListValueMust(
		VolumesType{
			basetypes.ObjectType{
				AttrTypes: VolumesValue{}.AttributeTypes(ctx),
			},
		},
		v.Volumes.Elements(),
	)

	if v.Volumes.IsNull() {
		volumes = types.ListNull(
			VolumesType{
				basetypes.ObjectType{
					AttrTypes: VolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Volumes.IsUnknown() {
		volumes = types.ListUnknown(
			VolumesType{
				basetypes.ObjectType{
					AttrTypes: VolumesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"volumes": basetypes.ListType{
			ElemType: VolumesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"volumes": volumes,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"volumes": basetypes.ListType{
			ElemType: VolumesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = VolumesType{}

type VolumesType struct {
	basetypes.ObjectType
}

func (t VolumesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesType) String() string {
	return "VolumesType"
}

func (t VolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachedToAttribute, ok := attributes["attached_to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached_to is missing from object`)

		return nil, diags
	}

	attachedToVal, ok := attachedToAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached_to expected to be basetypes.ListValue, was: %T`, attachedToAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	mountedByAttribute, ok := attributes["mounted_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mounted_by is missing from object`)

		return nil, diags
	}

	mountedByVal, ok := mountedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mounted_by expected to be basetypes.ListValue, was: %T`, mountedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	persistentAttribute, ok := attributes["persistent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persistent is missing from object`)

		return nil, diags
	}

	persistentVal, ok := persistentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persistent expected to be basetypes.BoolValue, was: %T`, persistentAttribute))
	}

	sizeMbAttribute, ok := attributes["size_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_mb is missing from object`)

		return nil, diags
	}

	sizeMbVal, ok := sizeMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_mb expected to be basetypes.Int64Value, was: %T`, sizeMbAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesValue{
		AttachedTo: attachedToVal,
		CreatedAt:  createdAtVal,
		MountedBy:  mountedByVal,
		Name:       nameVal,
		Persistent: persistentVal,
		SizeMb:     sizeMbVal,
		State:      stateVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueNull() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesValueUnknown() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesValue Attribute Value",
				"While creating a VolumesValue value, a missing attribute value was detected. "+
					"A VolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesValue Attribute Type",
				"While creating a VolumesValue value, an invalid attribute value was detected. "+
					"A VolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesValue Attribute Value",
				"While creating a VolumesValue value, an extra attribute value was detected. "+
					"A VolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	attachedToAttribute, ok := attributes["attached_to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached_to is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	attachedToVal, ok := attachedToAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached_to expected to be basetypes.ListValue, was: %T`, attachedToAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	mountedByAttribute, ok := attributes["mounted_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mounted_by is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	mountedByVal, ok := mountedByAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mounted_by expected to be basetypes.ListValue, was: %T`, mountedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	persistentAttribute, ok := attributes["persistent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persistent is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	persistentVal, ok := persistentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persistent expected to be basetypes.BoolValue, was: %T`, persistentAttribute))
	}

	sizeMbAttribute, ok := attributes["size_mb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_mb is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	sizeMbVal, ok := sizeMbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_mb expected to be basetypes.Int64Value, was: %T`, sizeMbAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	return VolumesValue{
		AttachedTo: attachedToVal,
		CreatedAt:  createdAtVal,
		MountedBy:  mountedByVal,
		Name:       nameVal,
		Persistent: persistentVal,
		SizeMb:     sizeMbVal,
		State:      stateVal,
		Uuid:       uuidVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesValue {
	object, diags := NewVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesValueMust(VolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesType) ValueType(ctx context.Context) attr.Value {
	return VolumesValue{}
}

var _ basetypes.ObjectValuable = VolumesValue{}

type VolumesValue struct {
	AttachedTo basetypes.ListValue   `tfsdk:"attached_to"`
	CreatedAt  basetypes.StringValue `tfsdk:"created_at"`
	MountedBy  basetypes.ListValue   `tfsdk:"mounted_by"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Persistent basetypes.BoolValue   `tfsdk:"persistent"`
	SizeMb     basetypes.Int64Value  `tfsdk:"size_mb"`
	State      basetypes.StringValue `tfsdk:"state"`
	Uuid       basetypes.StringValue `tfsdk:"uuid"`
	state      attr.ValueState
}

func (v VolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["attached_to"] = basetypes.ListType{
		ElemType: AttachedToValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mounted_by"] = basetypes.ListType{
		ElemType: MountedByValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["persistent"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["size_mb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AttachedTo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attached_to"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.MountedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mounted_by"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Persistent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["persistent"] = val

		val, err = v.SizeMb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_mb"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesValue) String() string {
	return "VolumesValue"
}

func (v VolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attachedTo := types.ListValueMust(
		AttachedToType{
			basetypes.ObjectType{
				AttrTypes: AttachedToValue{}.AttributeTypes(ctx),
			},
		},
		v.AttachedTo.Elements(),
	)

	if v.AttachedTo.IsNull() {
		attachedTo = types.ListNull(
			AttachedToType{
				basetypes.ObjectType{
					AttrTypes: AttachedToValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AttachedTo.IsUnknown() {
		attachedTo = types.ListUnknown(
			AttachedToType{
				basetypes.ObjectType{
					AttrTypes: AttachedToValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	mountedBy := types.ListValueMust(
		MountedByType{
			basetypes.ObjectType{
				AttrTypes: MountedByValue{}.AttributeTypes(ctx),
			},
		},
		v.MountedBy.Elements(),
	)

	if v.MountedBy.IsNull() {
		mountedBy = types.ListNull(
			MountedByType{
				basetypes.ObjectType{
					AttrTypes: MountedByValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.MountedBy.IsUnknown() {
		mountedBy = types.ListUnknown(
			MountedByType{
				basetypes.ObjectType{
					AttrTypes: MountedByValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"attached_to": basetypes.ListType{
			ElemType: AttachedToValue{}.Type(ctx),
		},
		"created_at": basetypes.StringType{},
		"mounted_by": basetypes.ListType{
			ElemType: MountedByValue{}.Type(ctx),
		},
		"name":       basetypes.StringType{},
		"persistent": basetypes.BoolType{},
		"size_mb":    basetypes.Int64Type{},
		"state":      basetypes.StringType{},
		"uuid":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attached_to": attachedTo,
			"created_at":  v.CreatedAt,
			"mounted_by":  mountedBy,
			"name":        v.Name,
			"persistent":  v.Persistent,
			"size_mb":     v.SizeMb,
			"state":       v.State,
			"uuid":        v.Uuid,
		})

	return objVal, diags
}

func (v VolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachedTo.Equal(other.AttachedTo) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.MountedBy.Equal(other.MountedBy) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Persistent.Equal(other.Persistent) {
		return false
	}

	if !v.SizeMb.Equal(other.SizeMb) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v VolumesValue) Type(ctx context.Context) attr.Type {
	return VolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attached_to": basetypes.ListType{
			ElemType: AttachedToValue{}.Type(ctx),
		},
		"created_at": basetypes.StringType{},
		"mounted_by": basetypes.ListType{
			ElemType: MountedByValue{}.Type(ctx),
		},
		"name":       basetypes.StringType{},
		"persistent": basetypes.BoolType{},
		"size_mb":    basetypes.Int64Type{},
		"state":      basetypes.StringType{},
		"uuid":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttachedToType{}

type AttachedToType struct {
	basetypes.ObjectType
}

func (t AttachedToType) Equal(o attr.Type) bool {
	other, ok := o.(AttachedToType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachedToType) String() string {
	return "AttachedToType"
}

func (t AttachedToType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachedToValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAttachedToValueNull() AttachedToValue {
	return AttachedToValue{
		state: attr.ValueStateNull,
	}
}

func NewAttachedToValueUnknown() AttachedToValue {
	return AttachedToValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachedToValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachedToValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachedToValue Attribute Value",
				"While creating a AttachedToValue value, a missing attribute value was detected. "+
					"A AttachedToValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachedToValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachedToValue Attribute Type",
				"While creating a AttachedToValue value, an invalid attribute value was detected. "+
					"A AttachedToValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachedToValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachedToValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachedToValue Attribute Value",
				"While creating a AttachedToValue value, an extra attribute value was detected. "+
					"A AttachedToValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachedToValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachedToValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAttachedToValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewAttachedToValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewAttachedToValueUnknown(), diags
	}

	return AttachedToValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewAttachedToValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachedToValue {
	object, diags := NewAttachedToValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachedToValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachedToType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachedToValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachedToValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachedToValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachedToValueMust(AttachedToValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachedToType) ValueType(ctx context.Context) attr.Value {
	return AttachedToValue{}
}

var _ basetypes.ObjectValuable = AttachedToValue{}

type AttachedToValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v AttachedToValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachedToValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachedToValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachedToValue) String() string {
	return "AttachedToValue"
}

func (v AttachedToValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v AttachedToValue) Equal(o attr.Value) bool {
	other, ok := o.(AttachedToValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v AttachedToValue) Type(ctx context.Context) attr.Type {
	return AttachedToType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachedToValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MountedByType{}

type MountedByType struct {
	basetypes.ObjectType
}

func (t MountedByType) Equal(o attr.Type) bool {
	other, ok := o.(MountedByType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MountedByType) String() string {
	return "MountedByType"
}

func (t MountedByType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return nil, diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MountedByValue{
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMountedByValueNull() MountedByValue {
	return MountedByValue{
		state: attr.ValueStateNull,
	}
}

func NewMountedByValueUnknown() MountedByValue {
	return MountedByValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMountedByValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MountedByValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MountedByValue Attribute Value",
				"While creating a MountedByValue value, a missing attribute value was detected. "+
					"A MountedByValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MountedByValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MountedByValue Attribute Type",
				"While creating a MountedByValue value, an invalid attribute value was detected. "+
					"A MountedByValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MountedByValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MountedByValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MountedByValue Attribute Value",
				"While creating a MountedByValue value, an extra attribute value was detected. "+
					"A MountedByValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MountedByValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMountedByValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMountedByValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	readOnlyAttribute, ok := attributes["read_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_only is missing from object`)

		return NewMountedByValueUnknown(), diags
	}

	readOnlyVal, ok := readOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_only expected to be basetypes.BoolValue, was: %T`, readOnlyAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewMountedByValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewMountedByValueUnknown(), diags
	}

	return MountedByValue{
		Name:     nameVal,
		ReadOnly: readOnlyVal,
		Uuid:     uuidVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMountedByValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MountedByValue {
	object, diags := NewMountedByValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMountedByValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MountedByType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMountedByValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMountedByValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMountedByValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMountedByValueMust(MountedByValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MountedByType) ValueType(ctx context.Context) attr.Value {
	return MountedByValue{}
}

var _ basetypes.ObjectValuable = MountedByValue{}

type MountedByValue struct {
	Name     basetypes.StringValue `tfsdk:"name"`
	ReadOnly basetypes.BoolValue   `tfsdk:"read_only"`
	Uuid     basetypes.StringValue `tfsdk:"uuid"`
	state    attr.ValueState
}

func (v MountedByValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ReadOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read_only"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MountedByValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MountedByValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MountedByValue) String() string {
	return "MountedByValue"
}

func (v MountedByValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"uuid":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":      v.Name,
			"read_only": v.ReadOnly,
			"uuid":      v.Uuid,
		})

	return objVal, diags
}

func (v MountedByValue) Equal(o attr.Value) bool {
	other, ok := o.(MountedByValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ReadOnly.Equal(other.ReadOnly) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v MountedByValue) Type(ctx context.Context) attr.Type {
	return MountedByType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MountedByValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":      basetypes.StringType{},
		"read_only": basetypes.BoolType{},
		"uuid":      basetypes.StringType{},
	}
}
