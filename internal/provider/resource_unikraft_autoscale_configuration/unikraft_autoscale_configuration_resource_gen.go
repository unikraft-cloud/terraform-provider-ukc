// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_unikraft_autoscale_configuration

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func UnikraftAutoscaleConfigurationResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"cooldown_time_ms": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The cooldown time in milliseconds for the autoscale configuration.",
				MarkdownDescription: "The cooldown time in milliseconds for the autoscale configuration.",
			},
			"create_args": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"roms": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"image": schema.StringAttribute{
								Required:            true,
								Description:         "The image of the ROM to use for the autoscale configuration.",
								MarkdownDescription: "The image of the ROM to use for the autoscale configuration.",
							},
							"name": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The name of the ROM to use for the autoscale configuration.",
								MarkdownDescription: "The name of the ROM to use for the autoscale configuration.",
							},
						},
						CustomType: RomsType{
							ObjectType: types.ObjectType{
								AttrTypes: RomsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
						Computed: true,
					},
					"template": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The name of the template to use for the autoscale configuration.",
								MarkdownDescription: "The name of the template to use for the autoscale configuration.",
							},
							"uuid": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "The UUID of the template to use for the autoscale configuration.",
								MarkdownDescription: "The UUID of the template to use for the autoscale configuration.",
							},
						},
						CustomType: TemplateType{
							ObjectType: types.ObjectType{
								AttrTypes: TemplateValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "The template reference for the autoscale configuration.",
						MarkdownDescription: "The template reference for the autoscale configuration.",
					},
				},
				CustomType: CreateArgsType{
					ObjectType: types.ObjectType{
						AttrTypes: CreateArgsValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The arguments to use when creating the autoscale configuration.",
				MarkdownDescription: "The arguments to use when creating the autoscale configuration.",
			},
			"max_size": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The maximum number of instances to keep running.",
				MarkdownDescription: "The maximum number of instances to keep running.",
			},
			"min_size": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The minimum number of instances to keep running.",
				MarkdownDescription: "The minimum number of instances to keep running.",
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The name of the service to create a configuration for.\nMutually exclusive with UUID.",
				MarkdownDescription: "The name of the service to create a configuration for.\nMutually exclusive with UUID.",
			},
			"policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"adjustment_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The type of adjustment to be made in the step policy.",
							MarkdownDescription: "The type of adjustment to be made in the step policy.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"change",
									"exact",
									"percentage",
								),
							},
						},
						"enabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If the policy is enabled.",
							MarkdownDescription: "If the policy is enabled.",
						},
						"metric": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Metric to use for the step policy.",
							MarkdownDescription: "Metric to use for the step policy.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"cpu",
								),
							},
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The name of the policy.",
							MarkdownDescription: "The name of the policy.",
						},
						"steps": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"adjustment": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "The adjustment value for the step.",
										MarkdownDescription: "The adjustment value for the step.",
									},
									"lower_bound": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Lower bound for the step.",
										MarkdownDescription: "Lower bound for the step.",
									},
									"upper_bound": schema.Int64Attribute{
										Optional:            true,
										Computed:            true,
										Description:         "Upper bound for the step.",
										MarkdownDescription: "Upper bound for the step.",
									},
								},
								CustomType: StepsType{
									ObjectType: types.ObjectType{
										AttrTypes: StepsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "The steps for the step policy.\nEach step defines an adjustment value and optional bounds.",
							MarkdownDescription: "The steps for the step policy.\nEach step defines an adjustment value and optional bounds.",
						},
					},
					CustomType: PoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The policies to apply to the autoscale configuration.",
				MarkdownDescription: "The policies to apply to the autoscale configuration.",
			},
			"uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The UUID of the service to create a configuration for.\nMutually exclusive with name.",
				MarkdownDescription: "The UUID of the service to create a configuration for.\nMutually exclusive with name.",
			},
			"warmup_time_ms": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The warmup time in milliseconds for new instances.",
				MarkdownDescription: "The warmup time in milliseconds for new instances.",
			},
		},
	}
}

type UnikraftAutoscaleConfigurationModel struct {
	CooldownTimeMs types.Int64     `tfsdk:"cooldown_time_ms"`
	CreateArgs     CreateArgsValue `tfsdk:"create_args"`
	MaxSize        types.Int64     `tfsdk:"max_size"`
	MinSize        types.Int64     `tfsdk:"min_size"`
	Name           types.String    `tfsdk:"name"`
	Policies       types.List      `tfsdk:"policies"`
	Uuid           types.String    `tfsdk:"uuid"`
	WarmupTimeMs   types.Int64     `tfsdk:"warmup_time_ms"`
}

var _ basetypes.ObjectTypable = CreateArgsType{}

type CreateArgsType struct {
	basetypes.ObjectType
}

func (t CreateArgsType) Equal(o attr.Type) bool {
	other, ok := o.(CreateArgsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CreateArgsType) String() string {
	return "CreateArgsType"
}

func (t CreateArgsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	romsAttribute, ok := attributes["roms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roms is missing from object`)

		return nil, diags
	}

	romsVal, ok := romsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roms expected to be basetypes.ObjectValue, was: %T`, romsAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return nil, diags
	}

	templateVal, ok := templateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.ObjectValue, was: %T`, templateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CreateArgsValue{
		Roms:     romsVal,
		Template: templateVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCreateArgsValueNull() CreateArgsValue {
	return CreateArgsValue{
		state: attr.ValueStateNull,
	}
}

func NewCreateArgsValueUnknown() CreateArgsValue {
	return CreateArgsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCreateArgsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CreateArgsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CreateArgsValue Attribute Value",
				"While creating a CreateArgsValue value, a missing attribute value was detected. "+
					"A CreateArgsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CreateArgsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CreateArgsValue Attribute Type",
				"While creating a CreateArgsValue value, an invalid attribute value was detected. "+
					"A CreateArgsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CreateArgsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CreateArgsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CreateArgsValue Attribute Value",
				"While creating a CreateArgsValue value, an extra attribute value was detected. "+
					"A CreateArgsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CreateArgsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCreateArgsValueUnknown(), diags
	}

	romsAttribute, ok := attributes["roms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roms is missing from object`)

		return NewCreateArgsValueUnknown(), diags
	}

	romsVal, ok := romsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roms expected to be basetypes.ObjectValue, was: %T`, romsAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return NewCreateArgsValueUnknown(), diags
	}

	templateVal, ok := templateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.ObjectValue, was: %T`, templateAttribute))
	}

	if diags.HasError() {
		return NewCreateArgsValueUnknown(), diags
	}

	return CreateArgsValue{
		Roms:     romsVal,
		Template: templateVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCreateArgsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CreateArgsValue {
	object, diags := NewCreateArgsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCreateArgsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CreateArgsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCreateArgsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCreateArgsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCreateArgsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCreateArgsValueMust(CreateArgsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CreateArgsType) ValueType(ctx context.Context) attr.Value {
	return CreateArgsValue{}
}

var _ basetypes.ObjectValuable = CreateArgsValue{}

type CreateArgsValue struct {
	Roms     basetypes.ObjectValue `tfsdk:"roms"`
	Template basetypes.ObjectValue `tfsdk:"template"`
	state    attr.ValueState
}

func (v CreateArgsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["roms"] = basetypes.ObjectType{
		AttrTypes: RomsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["template"] = basetypes.ObjectType{
		AttrTypes: TemplateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Roms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["roms"] = val

		val, err = v.Template.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CreateArgsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CreateArgsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CreateArgsValue) String() string {
	return "CreateArgsValue"
}

func (v CreateArgsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var roms basetypes.ObjectValue

	if v.Roms.IsNull() {
		roms = types.ObjectNull(
			RomsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Roms.IsUnknown() {
		roms = types.ObjectUnknown(
			RomsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Roms.IsNull() && !v.Roms.IsUnknown() {
		roms = types.ObjectValueMust(
			RomsValue{}.AttributeTypes(ctx),
			v.Roms.Attributes(),
		)
	}

	var template basetypes.ObjectValue

	if v.Template.IsNull() {
		template = types.ObjectNull(
			TemplateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Template.IsUnknown() {
		template = types.ObjectUnknown(
			TemplateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Template.IsNull() && !v.Template.IsUnknown() {
		template = types.ObjectValueMust(
			TemplateValue{}.AttributeTypes(ctx),
			v.Template.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"roms": basetypes.ObjectType{
			AttrTypes: RomsValue{}.AttributeTypes(ctx),
		},
		"template": basetypes.ObjectType{
			AttrTypes: TemplateValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"roms":     roms,
			"template": template,
		})

	return objVal, diags
}

func (v CreateArgsValue) Equal(o attr.Value) bool {
	other, ok := o.(CreateArgsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Roms.Equal(other.Roms) {
		return false
	}

	if !v.Template.Equal(other.Template) {
		return false
	}

	return true
}

func (v CreateArgsValue) Type(ctx context.Context) attr.Type {
	return CreateArgsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CreateArgsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"roms": basetypes.ObjectType{
			AttrTypes: RomsValue{}.AttributeTypes(ctx),
		},
		"template": basetypes.ObjectType{
			AttrTypes: TemplateValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RomsType{}

type RomsType struct {
	basetypes.ObjectType
}

func (t RomsType) Equal(o attr.Type) bool {
	other, ok := o.(RomsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RomsType) String() string {
	return "RomsType"
}

func (t RomsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RomsValue{
		Image: imageVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRomsValueNull() RomsValue {
	return RomsValue{
		state: attr.ValueStateNull,
	}
}

func NewRomsValueUnknown() RomsValue {
	return RomsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRomsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RomsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RomsValue Attribute Value",
				"While creating a RomsValue value, a missing attribute value was detected. "+
					"A RomsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RomsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RomsValue Attribute Type",
				"While creating a RomsValue value, an invalid attribute value was detected. "+
					"A RomsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RomsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RomsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RomsValue Attribute Value",
				"While creating a RomsValue value, an extra attribute value was detected. "+
					"A RomsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RomsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRomsValueUnknown(), diags
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewRomsValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRomsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewRomsValueUnknown(), diags
	}

	return RomsValue{
		Image: imageVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRomsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RomsValue {
	object, diags := NewRomsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRomsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RomsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRomsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRomsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRomsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRomsValueMust(RomsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RomsType) ValueType(ctx context.Context) attr.Value {
	return RomsValue{}
}

var _ basetypes.ObjectValuable = RomsValue{}

type RomsValue struct {
	Image basetypes.StringValue `tfsdk:"image"`
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v RomsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RomsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RomsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RomsValue) String() string {
	return "RomsValue"
}

func (v RomsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"image": basetypes.StringType{},
		"name":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"image": v.Image,
			"name":  v.Name,
		})

	return objVal, diags
}

func (v RomsValue) Equal(o attr.Value) bool {
	other, ok := o.(RomsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v RomsValue) Type(ctx context.Context) attr.Type {
	return RomsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RomsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"image": basetypes.StringType{},
		"name":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TemplateType{}

type TemplateType struct {
	basetypes.ObjectType
}

func (t TemplateType) Equal(o attr.Type) bool {
	other, ok := o.(TemplateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TemplateType) String() string {
	return "TemplateType"
}

func (t TemplateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TemplateValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTemplateValueNull() TemplateValue {
	return TemplateValue{
		state: attr.ValueStateNull,
	}
}

func NewTemplateValueUnknown() TemplateValue {
	return TemplateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTemplateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TemplateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TemplateValue Attribute Value",
				"While creating a TemplateValue value, a missing attribute value was detected. "+
					"A TemplateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemplateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TemplateValue Attribute Type",
				"While creating a TemplateValue value, an invalid attribute value was detected. "+
					"A TemplateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemplateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TemplateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TemplateValue Attribute Value",
				"While creating a TemplateValue value, an extra attribute value was detected. "+
					"A TemplateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TemplateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTemplateValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewTemplateValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewTemplateValueUnknown(), diags
	}

	return TemplateValue{
		Name:  nameVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTemplateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TemplateValue {
	object, diags := NewTemplateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTemplateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TemplateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTemplateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTemplateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTemplateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTemplateValueMust(TemplateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TemplateType) ValueType(ctx context.Context) attr.Value {
	return TemplateValue{}
}

var _ basetypes.ObjectValuable = TemplateValue{}

type TemplateValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v TemplateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TemplateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TemplateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TemplateValue) String() string {
	return "TemplateValue"
}

func (v TemplateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v TemplateValue) Equal(o attr.Value) bool {
	other, ok := o.(TemplateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v TemplateValue) Type(ctx context.Context) attr.Type {
	return TemplateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TemplateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PoliciesType{}

type PoliciesType struct {
	basetypes.ObjectType
}

func (t PoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(PoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PoliciesType) String() string {
	return "PoliciesType"
}

func (t PoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	adjustmentTypeAttribute, ok := attributes["adjustment_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`adjustment_type is missing from object`)

		return nil, diags
	}

	adjustmentTypeVal, ok := adjustmentTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`adjustment_type expected to be basetypes.StringValue, was: %T`, adjustmentTypeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.StringValue, was: %T`, metricAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stepsAttribute, ok := attributes["steps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`steps is missing from object`)

		return nil, diags
	}

	stepsVal, ok := stepsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`steps expected to be basetypes.ListValue, was: %T`, stepsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PoliciesValue{
		AdjustmentType: adjustmentTypeVal,
		Enabled:        enabledVal,
		Metric:         metricVal,
		Name:           nameVal,
		Steps:          stepsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPoliciesValueNull() PoliciesValue {
	return PoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewPoliciesValueUnknown() PoliciesValue {
	return PoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PoliciesValue Attribute Value",
				"While creating a PoliciesValue value, a missing attribute value was detected. "+
					"A PoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PoliciesValue Attribute Type",
				"While creating a PoliciesValue value, an invalid attribute value was detected. "+
					"A PoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PoliciesValue Attribute Value",
				"While creating a PoliciesValue value, an extra attribute value was detected. "+
					"A PoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPoliciesValueUnknown(), diags
	}

	adjustmentTypeAttribute, ok := attributes["adjustment_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`adjustment_type is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	adjustmentTypeVal, ok := adjustmentTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`adjustment_type expected to be basetypes.StringValue, was: %T`, adjustmentTypeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.StringValue, was: %T`, metricAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	stepsAttribute, ok := attributes["steps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`steps is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	stepsVal, ok := stepsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`steps expected to be basetypes.ListValue, was: %T`, stepsAttribute))
	}

	if diags.HasError() {
		return NewPoliciesValueUnknown(), diags
	}

	return PoliciesValue{
		AdjustmentType: adjustmentTypeVal,
		Enabled:        enabledVal,
		Metric:         metricVal,
		Name:           nameVal,
		Steps:          stepsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PoliciesValue {
	object, diags := NewPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPoliciesValueMust(PoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PoliciesType) ValueType(ctx context.Context) attr.Value {
	return PoliciesValue{}
}

var _ basetypes.ObjectValuable = PoliciesValue{}

type PoliciesValue struct {
	AdjustmentType basetypes.StringValue `tfsdk:"adjustment_type"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	Metric         basetypes.StringValue `tfsdk:"metric"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Steps          basetypes.ListValue   `tfsdk:"steps"`
	state          attr.ValueState
}

func (v PoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["adjustment_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["steps"] = basetypes.ListType{
		ElemType: StepsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AdjustmentType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["adjustment_type"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Steps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["steps"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PoliciesValue) String() string {
	return "PoliciesValue"
}

func (v PoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	steps := types.ListValueMust(
		StepsType{
			basetypes.ObjectType{
				AttrTypes: StepsValue{}.AttributeTypes(ctx),
			},
		},
		v.Steps.Elements(),
	)

	if v.Steps.IsNull() {
		steps = types.ListNull(
			StepsType{
				basetypes.ObjectType{
					AttrTypes: StepsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Steps.IsUnknown() {
		steps = types.ListUnknown(
			StepsType{
				basetypes.ObjectType{
					AttrTypes: StepsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"adjustment_type": basetypes.StringType{},
		"enabled":         basetypes.BoolType{},
		"metric":          basetypes.StringType{},
		"name":            basetypes.StringType{},
		"steps": basetypes.ListType{
			ElemType: StepsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"adjustment_type": v.AdjustmentType,
			"enabled":         v.Enabled,
			"metric":          v.Metric,
			"name":            v.Name,
			"steps":           steps,
		})

	return objVal, diags
}

func (v PoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(PoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdjustmentType.Equal(other.AdjustmentType) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Steps.Equal(other.Steps) {
		return false
	}

	return true
}

func (v PoliciesValue) Type(ctx context.Context) attr.Type {
	return PoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"adjustment_type": basetypes.StringType{},
		"enabled":         basetypes.BoolType{},
		"metric":          basetypes.StringType{},
		"name":            basetypes.StringType{},
		"steps": basetypes.ListType{
			ElemType: StepsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = StepsType{}

type StepsType struct {
	basetypes.ObjectType
}

func (t StepsType) Equal(o attr.Type) bool {
	other, ok := o.(StepsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StepsType) String() string {
	return "StepsType"
}

func (t StepsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	adjustmentAttribute, ok := attributes["adjustment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`adjustment is missing from object`)

		return nil, diags
	}

	adjustmentVal, ok := adjustmentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`adjustment expected to be basetypes.Int64Value, was: %T`, adjustmentAttribute))
	}

	lowerBoundAttribute, ok := attributes["lower_bound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lower_bound is missing from object`)

		return nil, diags
	}

	lowerBoundVal, ok := lowerBoundAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lower_bound expected to be basetypes.Int64Value, was: %T`, lowerBoundAttribute))
	}

	upperBoundAttribute, ok := attributes["upper_bound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upper_bound is missing from object`)

		return nil, diags
	}

	upperBoundVal, ok := upperBoundAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upper_bound expected to be basetypes.Int64Value, was: %T`, upperBoundAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StepsValue{
		Adjustment: adjustmentVal,
		LowerBound: lowerBoundVal,
		UpperBound: upperBoundVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStepsValueNull() StepsValue {
	return StepsValue{
		state: attr.ValueStateNull,
	}
}

func NewStepsValueUnknown() StepsValue {
	return StepsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStepsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StepsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StepsValue Attribute Value",
				"While creating a StepsValue value, a missing attribute value was detected. "+
					"A StepsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StepsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StepsValue Attribute Type",
				"While creating a StepsValue value, an invalid attribute value was detected. "+
					"A StepsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StepsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StepsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StepsValue Attribute Value",
				"While creating a StepsValue value, an extra attribute value was detected. "+
					"A StepsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StepsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStepsValueUnknown(), diags
	}

	adjustmentAttribute, ok := attributes["adjustment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`adjustment is missing from object`)

		return NewStepsValueUnknown(), diags
	}

	adjustmentVal, ok := adjustmentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`adjustment expected to be basetypes.Int64Value, was: %T`, adjustmentAttribute))
	}

	lowerBoundAttribute, ok := attributes["lower_bound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lower_bound is missing from object`)

		return NewStepsValueUnknown(), diags
	}

	lowerBoundVal, ok := lowerBoundAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lower_bound expected to be basetypes.Int64Value, was: %T`, lowerBoundAttribute))
	}

	upperBoundAttribute, ok := attributes["upper_bound"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upper_bound is missing from object`)

		return NewStepsValueUnknown(), diags
	}

	upperBoundVal, ok := upperBoundAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upper_bound expected to be basetypes.Int64Value, was: %T`, upperBoundAttribute))
	}

	if diags.HasError() {
		return NewStepsValueUnknown(), diags
	}

	return StepsValue{
		Adjustment: adjustmentVal,
		LowerBound: lowerBoundVal,
		UpperBound: upperBoundVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStepsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StepsValue {
	object, diags := NewStepsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStepsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StepsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStepsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStepsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStepsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStepsValueMust(StepsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StepsType) ValueType(ctx context.Context) attr.Value {
	return StepsValue{}
}

var _ basetypes.ObjectValuable = StepsValue{}

type StepsValue struct {
	Adjustment basetypes.Int64Value `tfsdk:"adjustment"`
	LowerBound basetypes.Int64Value `tfsdk:"lower_bound"`
	UpperBound basetypes.Int64Value `tfsdk:"upper_bound"`
	state      attr.ValueState
}

func (v StepsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["adjustment"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["lower_bound"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["upper_bound"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Adjustment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["adjustment"] = val

		val, err = v.LowerBound.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lower_bound"] = val

		val, err = v.UpperBound.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["upper_bound"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StepsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StepsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StepsValue) String() string {
	return "StepsValue"
}

func (v StepsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"adjustment":  basetypes.Int64Type{},
		"lower_bound": basetypes.Int64Type{},
		"upper_bound": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"adjustment":  v.Adjustment,
			"lower_bound": v.LowerBound,
			"upper_bound": v.UpperBound,
		})

	return objVal, diags
}

func (v StepsValue) Equal(o attr.Value) bool {
	other, ok := o.(StepsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Adjustment.Equal(other.Adjustment) {
		return false
	}

	if !v.LowerBound.Equal(other.LowerBound) {
		return false
	}

	if !v.UpperBound.Equal(other.UpperBound) {
		return false
	}

	return true
}

func (v StepsValue) Type(ctx context.Context) attr.Type {
	return StepsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StepsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"adjustment":  basetypes.Int64Type{},
		"lower_bound": basetypes.Int64Type{},
		"upper_bound": basetypes.Int64Type{},
	}
}
