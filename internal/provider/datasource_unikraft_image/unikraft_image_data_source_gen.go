// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_unikraft_image

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func UnikraftImageDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"data": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"image": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"arch": schema.StringAttribute{
								Computed:            true,
								Description:         "The architecture of the image.",
								MarkdownDescription: "The architecture of the image.",
							},
							"auxiliary_roms": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"digest": schema.StringAttribute{
											Computed:            true,
											Description:         "The digest is a string representation including the hashing\nalgorithm and the hash value separated by a colon.",
											MarkdownDescription: "The digest is a string representation including the hashing\nalgorithm and the hash value separated by a colon.",
										},
										"media_type": schema.StringAttribute{
											Computed:            true,
											Description:         "The media type of the layer is a string that identifies the type of\ncontent that the layer contains.",
											MarkdownDescription: "The media type of the layer is a string that identifies the type of\ncontent that the layer contains.",
										},
										"size": schema.Int64Attribute{
											Computed:            true,
											Description:         "The size of the layer in bytes.",
											MarkdownDescription: "The size of the layer in bytes.",
										},
									},
									CustomType: AuxiliaryRomsType{
										ObjectType: types.ObjectType{
											AttrTypes: AuxiliaryRomsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Computed:            true,
								Description:         "List of auxiliary ROMs that are used by the image.",
								MarkdownDescription: "List of auxiliary ROMs that are used by the image.",
							},
							"cmd": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The command to run when the image is started.",
								MarkdownDescription: "The command to run when the image is started.",
							},
							"created_at": schema.StringAttribute{
								Computed:            true,
								Description:         "When the image was created.",
								MarkdownDescription: "When the image was created.",
							},
							"description": schema.StringAttribute{
								Computed:            true,
								Description:         "A description of the image.",
								MarkdownDescription: "A description of the image.",
							},
							"digest": schema.StringAttribute{
								Computed:            true,
								Description:         "The digest of the image is a unique identifier of the image manifest which\nis a string representation including the hashing algorithm and the hash\nvalue separated by a colon.",
								MarkdownDescription: "The digest of the image is a unique identifier of the image manifest which\nis a string representation including the hashing algorithm and the hash\nvalue separated by a colon.",
							},
							"entrypoint": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The entrypoint of the image is the command that is run when the image is\nstarted.",
								MarkdownDescription: "The entrypoint of the image is the command that is run when the image is\nstarted.",
							},
							"env": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The environment variables to set when the image is started.",
								MarkdownDescription: "The environment variables to set when the image is started.",
							},
							"kernel": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"digest": schema.StringAttribute{
										Computed:            true,
										Description:         "The digest is a string representation including the hashing\nalgorithm and the hash value separated by a colon.",
										MarkdownDescription: "The digest is a string representation including the hashing\nalgorithm and the hash value separated by a colon.",
									},
									"media_type": schema.StringAttribute{
										Computed:            true,
										Description:         "The media type of the layer is a string that identifies the type of\ncontent that the layer contains.",
										MarkdownDescription: "The media type of the layer is a string that identifies the type of\ncontent that the layer contains.",
									},
									"size": schema.Int64Attribute{
										Computed:            true,
										Description:         "The size of the layer in bytes.",
										MarkdownDescription: "The size of the layer in bytes.",
									},
								},
								CustomType: KernelType{
									ObjectType: types.ObjectType{
										AttrTypes: KernelValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "The kernel object is a reference to the kernel that is used by the image.",
								MarkdownDescription: "The kernel object is a reference to the kernel that is used by the image.",
							},
							"labels": schema.MapAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "Labels are key-value pairs.",
								MarkdownDescription: "Labels are key-value pairs.",
							},
							"ports": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "Documented port mappings for the image.",
								MarkdownDescription: "Documented port mappings for the image.",
							},
							"tag": schema.StringAttribute{
								Computed:            true,
								Description:         "The canonical name of the image is known as the \"tag\".",
								MarkdownDescription: "The canonical name of the image is known as the \"tag\".",
							},
							"volumes": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "Documented volumes for the image.",
								MarkdownDescription: "Documented volumes for the image.",
							},
							"workdir": schema.StringAttribute{
								Computed:            true,
								Description:         "The working directory for the image is the directory that is set as the\ncurrent working directory when the image is started.",
								MarkdownDescription: "The working directory for the image is the directory that is set as the\ncurrent working directory when the image is started.",
							},
						},
						CustomType: ImageType{
							ObjectType: types.ObjectType{
								AttrTypes: ImageValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "The instance that was created in this request.",
						MarkdownDescription: "The instance that was created in this request.",
					},
				},
				CustomType: DataType{
					ObjectType: types.ObjectType{
						AttrTypes: DataValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "The response data for this request.",
				MarkdownDescription: "The response data for this request.",
			},
			"message": schema.StringAttribute{
				Computed:            true,
				Description:         "An optional message providing additional information about the response.",
				MarkdownDescription: "An optional message providing additional information about the response.",
			},
			"op_time_us": schema.Int64Attribute{
				Computed:            true,
				Description:         "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
				MarkdownDescription: "The operation time in microseconds.  This is the time it took to process\nthe request and generate the response.",
			},
			"status": schema.StringAttribute{
				Computed:            true,
				Description:         "The status of the response.",
				MarkdownDescription: "The status of the response.",
			},
			"tag": schema.StringAttribute{
				Required: true,
			},
		},
	}
}

type UnikraftImageModel struct {
	Data     DataValue    `tfsdk:"data"`
	Message  types.String `tfsdk:"message"`
	OpTimeUs types.Int64  `tfsdk:"op_time_us"`
	Status   types.String `tfsdk:"status"`
	Tag      types.String `tfsdk:"tag"`
}

var _ basetypes.ObjectTypable = DataType{}

type DataType struct {
	basetypes.ObjectType
}

func (t DataType) Equal(o attr.Type) bool {
	other, ok := o.(DataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DataType) String() string {
	return "DataType"
}

func (t DataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.ObjectValue, was: %T`, imageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DataValue{
		Image: imageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDataValueNull() DataValue {
	return DataValue{
		state: attr.ValueStateNull,
	}
}

func NewDataValueUnknown() DataValue {
	return DataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DataValue Attribute Value",
				"While creating a DataValue value, a missing attribute value was detected. "+
					"A DataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DataValue Attribute Type",
				"While creating a DataValue value, an invalid attribute value was detected. "+
					"A DataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DataValue Attribute Value",
				"While creating a DataValue value, an extra attribute value was detected. "+
					"A DataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewDataValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.ObjectValue, was: %T`, imageAttribute))
	}

	if diags.HasError() {
		return NewDataValueUnknown(), diags
	}

	return DataValue{
		Image: imageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DataValue {
	object, diags := NewDataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDataValueMust(DataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DataType) ValueType(ctx context.Context) attr.Value {
	return DataValue{}
}

var _ basetypes.ObjectValuable = DataValue{}

type DataValue struct {
	Image basetypes.ObjectValue `tfsdk:"image"`
	state attr.ValueState
}

func (v DataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["image"] = basetypes.ObjectType{
		AttrTypes: ImageValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DataValue) String() string {
	return "DataValue"
}

func (v DataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var image basetypes.ObjectValue

	if v.Image.IsNull() {
		image = types.ObjectNull(
			ImageValue{}.AttributeTypes(ctx),
		)
	}

	if v.Image.IsUnknown() {
		image = types.ObjectUnknown(
			ImageValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Image.IsNull() && !v.Image.IsUnknown() {
		image = types.ObjectValueMust(
			ImageValue{}.AttributeTypes(ctx),
			v.Image.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"image": basetypes.ObjectType{
			AttrTypes: ImageValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"image": image,
		})

	return objVal, diags
}

func (v DataValue) Equal(o attr.Value) bool {
	other, ok := o.(DataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	return true
}

func (v DataValue) Type(ctx context.Context) attr.Type {
	return DataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"image": basetypes.ObjectType{
			AttrTypes: ImageValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ImageType{}

type ImageType struct {
	basetypes.ObjectType
}

func (t ImageType) Equal(o attr.Type) bool {
	other, ok := o.(ImageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImageType) String() string {
	return "ImageType"
}

func (t ImageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archAttribute, ok := attributes["arch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arch is missing from object`)

		return nil, diags
	}

	archVal, ok := archAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arch expected to be basetypes.StringValue, was: %T`, archAttribute))
	}

	auxiliaryRomsAttribute, ok := attributes["auxiliary_roms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auxiliary_roms is missing from object`)

		return nil, diags
	}

	auxiliaryRomsVal, ok := auxiliaryRomsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auxiliary_roms expected to be basetypes.ListValue, was: %T`, auxiliaryRomsAttribute))
	}

	cmdAttribute, ok := attributes["cmd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cmd is missing from object`)

		return nil, diags
	}

	cmdVal, ok := cmdAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cmd expected to be basetypes.ListValue, was: %T`, cmdAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	digestAttribute, ok := attributes["digest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`digest is missing from object`)

		return nil, diags
	}

	digestVal, ok := digestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`digest expected to be basetypes.StringValue, was: %T`, digestAttribute))
	}

	entrypointAttribute, ok := attributes["entrypoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entrypoint is missing from object`)

		return nil, diags
	}

	entrypointVal, ok := entrypointAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entrypoint expected to be basetypes.ListValue, was: %T`, entrypointAttribute))
	}

	envAttribute, ok := attributes["env"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env is missing from object`)

		return nil, diags
	}

	envVal, ok := envAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env expected to be basetypes.ListValue, was: %T`, envAttribute))
	}

	kernelAttribute, ok := attributes["kernel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kernel is missing from object`)

		return nil, diags
	}

	kernelVal, ok := kernelAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kernel expected to be basetypes.ObjectValue, was: %T`, kernelAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return nil, diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return nil, diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return nil, diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.ListValue, was: %T`, volumesAttribute))
	}

	workdirAttribute, ok := attributes["workdir"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`workdir is missing from object`)

		return nil, diags
	}

	workdirVal, ok := workdirAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`workdir expected to be basetypes.StringValue, was: %T`, workdirAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImageValue{
		Arch:          archVal,
		AuxiliaryRoms: auxiliaryRomsVal,
		Cmd:           cmdVal,
		CreatedAt:     createdAtVal,
		Description:   descriptionVal,
		Digest:        digestVal,
		Entrypoint:    entrypointVal,
		Env:           envVal,
		Kernel:        kernelVal,
		Labels:        labelsVal,
		Ports:         portsVal,
		Tag:           tagVal,
		Volumes:       volumesVal,
		Workdir:       workdirVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewImageValueNull() ImageValue {
	return ImageValue{
		state: attr.ValueStateNull,
	}
}

func NewImageValueUnknown() ImageValue {
	return ImageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImageValue Attribute Value",
				"While creating a ImageValue value, a missing attribute value was detected. "+
					"A ImageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImageValue Attribute Type",
				"While creating a ImageValue value, an invalid attribute value was detected. "+
					"A ImageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImageValue Attribute Value",
				"While creating a ImageValue value, an extra attribute value was detected. "+
					"A ImageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	archAttribute, ok := attributes["arch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arch is missing from object`)

		return NewImageValueUnknown(), diags
	}

	archVal, ok := archAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arch expected to be basetypes.StringValue, was: %T`, archAttribute))
	}

	auxiliaryRomsAttribute, ok := attributes["auxiliary_roms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auxiliary_roms is missing from object`)

		return NewImageValueUnknown(), diags
	}

	auxiliaryRomsVal, ok := auxiliaryRomsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auxiliary_roms expected to be basetypes.ListValue, was: %T`, auxiliaryRomsAttribute))
	}

	cmdAttribute, ok := attributes["cmd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cmd is missing from object`)

		return NewImageValueUnknown(), diags
	}

	cmdVal, ok := cmdAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cmd expected to be basetypes.ListValue, was: %T`, cmdAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewImageValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewImageValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	digestAttribute, ok := attributes["digest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`digest is missing from object`)

		return NewImageValueUnknown(), diags
	}

	digestVal, ok := digestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`digest expected to be basetypes.StringValue, was: %T`, digestAttribute))
	}

	entrypointAttribute, ok := attributes["entrypoint"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entrypoint is missing from object`)

		return NewImageValueUnknown(), diags
	}

	entrypointVal, ok := entrypointAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entrypoint expected to be basetypes.ListValue, was: %T`, entrypointAttribute))
	}

	envAttribute, ok := attributes["env"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env is missing from object`)

		return NewImageValueUnknown(), diags
	}

	envVal, ok := envAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env expected to be basetypes.ListValue, was: %T`, envAttribute))
	}

	kernelAttribute, ok := attributes["kernel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kernel is missing from object`)

		return NewImageValueUnknown(), diags
	}

	kernelVal, ok := kernelAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kernel expected to be basetypes.ObjectValue, was: %T`, kernelAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewImageValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return NewImageValueUnknown(), diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return NewImageValueUnknown(), diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	volumesAttribute, ok := attributes["volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`volumes is missing from object`)

		return NewImageValueUnknown(), diags
	}

	volumesVal, ok := volumesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`volumes expected to be basetypes.ListValue, was: %T`, volumesAttribute))
	}

	workdirAttribute, ok := attributes["workdir"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`workdir is missing from object`)

		return NewImageValueUnknown(), diags
	}

	workdirVal, ok := workdirAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`workdir expected to be basetypes.StringValue, was: %T`, workdirAttribute))
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	return ImageValue{
		Arch:          archVal,
		AuxiliaryRoms: auxiliaryRomsVal,
		Cmd:           cmdVal,
		CreatedAt:     createdAtVal,
		Description:   descriptionVal,
		Digest:        digestVal,
		Entrypoint:    entrypointVal,
		Env:           envVal,
		Kernel:        kernelVal,
		Labels:        labelsVal,
		Ports:         portsVal,
		Tag:           tagVal,
		Volumes:       volumesVal,
		Workdir:       workdirVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewImageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImageValue {
	object, diags := NewImageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImageValueMust(ImageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImageType) ValueType(ctx context.Context) attr.Value {
	return ImageValue{}
}

var _ basetypes.ObjectValuable = ImageValue{}

type ImageValue struct {
	Arch          basetypes.StringValue `tfsdk:"arch"`
	AuxiliaryRoms basetypes.ListValue   `tfsdk:"auxiliary_roms"`
	Cmd           basetypes.ListValue   `tfsdk:"cmd"`
	CreatedAt     basetypes.StringValue `tfsdk:"created_at"`
	Description   basetypes.StringValue `tfsdk:"description"`
	Digest        basetypes.StringValue `tfsdk:"digest"`
	Entrypoint    basetypes.ListValue   `tfsdk:"entrypoint"`
	Env           basetypes.ListValue   `tfsdk:"env"`
	Kernel        basetypes.ObjectValue `tfsdk:"kernel"`
	Labels        basetypes.MapValue    `tfsdk:"labels"`
	Ports         basetypes.ListValue   `tfsdk:"ports"`
	Tag           basetypes.StringValue `tfsdk:"tag"`
	Volumes       basetypes.ListValue   `tfsdk:"volumes"`
	Workdir       basetypes.StringValue `tfsdk:"workdir"`
	state         attr.ValueState
}

func (v ImageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["arch"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auxiliary_roms"] = basetypes.ListType{
		ElemType: AuxiliaryRomsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["cmd"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["digest"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["entrypoint"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["env"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["kernel"] = basetypes.ObjectType{
		AttrTypes: KernelValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["ports"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tag"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["volumes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["workdir"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.Arch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arch"] = val

		val, err = v.AuxiliaryRoms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auxiliary_roms"] = val

		val, err = v.Cmd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cmd"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Digest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["digest"] = val

		val, err = v.Entrypoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entrypoint"] = val

		val, err = v.Env.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["env"] = val

		val, err = v.Kernel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kernel"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Ports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports"] = val

		val, err = v.Tag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag"] = val

		val, err = v.Volumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["volumes"] = val

		val, err = v.Workdir.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["workdir"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImageValue) String() string {
	return "ImageValue"
}

func (v ImageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	auxiliaryRoms := types.ListValueMust(
		AuxiliaryRomsType{
			basetypes.ObjectType{
				AttrTypes: AuxiliaryRomsValue{}.AttributeTypes(ctx),
			},
		},
		v.AuxiliaryRoms.Elements(),
	)

	if v.AuxiliaryRoms.IsNull() {
		auxiliaryRoms = types.ListNull(
			AuxiliaryRomsType{
				basetypes.ObjectType{
					AttrTypes: AuxiliaryRomsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuxiliaryRoms.IsUnknown() {
		auxiliaryRoms = types.ListUnknown(
			AuxiliaryRomsType{
				basetypes.ObjectType{
					AttrTypes: AuxiliaryRomsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var kernel basetypes.ObjectValue

	if v.Kernel.IsNull() {
		kernel = types.ObjectNull(
			KernelValue{}.AttributeTypes(ctx),
		)
	}

	if v.Kernel.IsUnknown() {
		kernel = types.ObjectUnknown(
			KernelValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Kernel.IsNull() && !v.Kernel.IsUnknown() {
		kernel = types.ObjectValueMust(
			KernelValue{}.AttributeTypes(ctx),
			v.Kernel.Attributes(),
		)
	}

	var cmdVal basetypes.ListValue
	switch {
	case v.Cmd.IsUnknown():
		cmdVal = types.ListUnknown(types.StringType)
	case v.Cmd.IsNull():
		cmdVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		cmdVal, d = types.ListValue(types.StringType, v.Cmd.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch": basetypes.StringType{},
			"auxiliary_roms": basetypes.ListType{
				ElemType: AuxiliaryRomsValue{}.Type(ctx),
			},
			"cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"created_at":  basetypes.StringType{},
			"description": basetypes.StringType{},
			"digest":      basetypes.StringType{},
			"entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"env": basetypes.ListType{
				ElemType: types.StringType,
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tag": basetypes.StringType{},
			"volumes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"workdir": basetypes.StringType{},
		}), diags
	}

	var entrypointVal basetypes.ListValue
	switch {
	case v.Entrypoint.IsUnknown():
		entrypointVal = types.ListUnknown(types.StringType)
	case v.Entrypoint.IsNull():
		entrypointVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		entrypointVal, d = types.ListValue(types.StringType, v.Entrypoint.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch": basetypes.StringType{},
			"auxiliary_roms": basetypes.ListType{
				ElemType: AuxiliaryRomsValue{}.Type(ctx),
			},
			"cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"created_at":  basetypes.StringType{},
			"description": basetypes.StringType{},
			"digest":      basetypes.StringType{},
			"entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"env": basetypes.ListType{
				ElemType: types.StringType,
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tag": basetypes.StringType{},
			"volumes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"workdir": basetypes.StringType{},
		}), diags
	}

	var envVal basetypes.ListValue
	switch {
	case v.Env.IsUnknown():
		envVal = types.ListUnknown(types.StringType)
	case v.Env.IsNull():
		envVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		envVal, d = types.ListValue(types.StringType, v.Env.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch": basetypes.StringType{},
			"auxiliary_roms": basetypes.ListType{
				ElemType: AuxiliaryRomsValue{}.Type(ctx),
			},
			"cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"created_at":  basetypes.StringType{},
			"description": basetypes.StringType{},
			"digest":      basetypes.StringType{},
			"entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"env": basetypes.ListType{
				ElemType: types.StringType,
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tag": basetypes.StringType{},
			"volumes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"workdir": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch": basetypes.StringType{},
			"auxiliary_roms": basetypes.ListType{
				ElemType: AuxiliaryRomsValue{}.Type(ctx),
			},
			"cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"created_at":  basetypes.StringType{},
			"description": basetypes.StringType{},
			"digest":      basetypes.StringType{},
			"entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"env": basetypes.ListType{
				ElemType: types.StringType,
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tag": basetypes.StringType{},
			"volumes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"workdir": basetypes.StringType{},
		}), diags
	}

	var portsVal basetypes.ListValue
	switch {
	case v.Ports.IsUnknown():
		portsVal = types.ListUnknown(types.StringType)
	case v.Ports.IsNull():
		portsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		portsVal, d = types.ListValue(types.StringType, v.Ports.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch": basetypes.StringType{},
			"auxiliary_roms": basetypes.ListType{
				ElemType: AuxiliaryRomsValue{}.Type(ctx),
			},
			"cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"created_at":  basetypes.StringType{},
			"description": basetypes.StringType{},
			"digest":      basetypes.StringType{},
			"entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"env": basetypes.ListType{
				ElemType: types.StringType,
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tag": basetypes.StringType{},
			"volumes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"workdir": basetypes.StringType{},
		}), diags
	}

	var volumesVal basetypes.ListValue
	switch {
	case v.Volumes.IsUnknown():
		volumesVal = types.ListUnknown(types.StringType)
	case v.Volumes.IsNull():
		volumesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		volumesVal, d = types.ListValue(types.StringType, v.Volumes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"arch": basetypes.StringType{},
			"auxiliary_roms": basetypes.ListType{
				ElemType: AuxiliaryRomsValue{}.Type(ctx),
			},
			"cmd": basetypes.ListType{
				ElemType: types.StringType,
			},
			"created_at":  basetypes.StringType{},
			"description": basetypes.StringType{},
			"digest":      basetypes.StringType{},
			"entrypoint": basetypes.ListType{
				ElemType: types.StringType,
			},
			"env": basetypes.ListType{
				ElemType: types.StringType,
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tag": basetypes.StringType{},
			"volumes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"workdir": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"arch": basetypes.StringType{},
		"auxiliary_roms": basetypes.ListType{
			ElemType: AuxiliaryRomsValue{}.Type(ctx),
		},
		"cmd": basetypes.ListType{
			ElemType: types.StringType,
		},
		"created_at":  basetypes.StringType{},
		"description": basetypes.StringType{},
		"digest":      basetypes.StringType{},
		"entrypoint": basetypes.ListType{
			ElemType: types.StringType,
		},
		"env": basetypes.ListType{
			ElemType: types.StringType,
		},
		"kernel": basetypes.ObjectType{
			AttrTypes: KernelValue{}.AttributeTypes(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tag": basetypes.StringType{},
		"volumes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"workdir": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arch":           v.Arch,
			"auxiliary_roms": auxiliaryRoms,
			"cmd":            cmdVal,
			"created_at":     v.CreatedAt,
			"description":    v.Description,
			"digest":         v.Digest,
			"entrypoint":     entrypointVal,
			"env":            envVal,
			"kernel":         kernel,
			"labels":         labelsVal,
			"ports":          portsVal,
			"tag":            v.Tag,
			"volumes":        volumesVal,
			"workdir":        v.Workdir,
		})

	return objVal, diags
}

func (v ImageValue) Equal(o attr.Value) bool {
	other, ok := o.(ImageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Arch.Equal(other.Arch) {
		return false
	}

	if !v.AuxiliaryRoms.Equal(other.AuxiliaryRoms) {
		return false
	}

	if !v.Cmd.Equal(other.Cmd) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Digest.Equal(other.Digest) {
		return false
	}

	if !v.Entrypoint.Equal(other.Entrypoint) {
		return false
	}

	if !v.Env.Equal(other.Env) {
		return false
	}

	if !v.Kernel.Equal(other.Kernel) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Ports.Equal(other.Ports) {
		return false
	}

	if !v.Tag.Equal(other.Tag) {
		return false
	}

	if !v.Volumes.Equal(other.Volumes) {
		return false
	}

	if !v.Workdir.Equal(other.Workdir) {
		return false
	}

	return true
}

func (v ImageValue) Type(ctx context.Context) attr.Type {
	return ImageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arch": basetypes.StringType{},
		"auxiliary_roms": basetypes.ListType{
			ElemType: AuxiliaryRomsValue{}.Type(ctx),
		},
		"cmd": basetypes.ListType{
			ElemType: types.StringType,
		},
		"created_at":  basetypes.StringType{},
		"description": basetypes.StringType{},
		"digest":      basetypes.StringType{},
		"entrypoint": basetypes.ListType{
			ElemType: types.StringType,
		},
		"env": basetypes.ListType{
			ElemType: types.StringType,
		},
		"kernel": basetypes.ObjectType{
			AttrTypes: KernelValue{}.AttributeTypes(ctx),
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tag": basetypes.StringType{},
		"volumes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"workdir": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuxiliaryRomsType{}

type AuxiliaryRomsType struct {
	basetypes.ObjectType
}

func (t AuxiliaryRomsType) Equal(o attr.Type) bool {
	other, ok := o.(AuxiliaryRomsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuxiliaryRomsType) String() string {
	return "AuxiliaryRomsType"
}

func (t AuxiliaryRomsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	digestAttribute, ok := attributes["digest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`digest is missing from object`)

		return nil, diags
	}

	digestVal, ok := digestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`digest expected to be basetypes.StringValue, was: %T`, digestAttribute))
	}

	mediaTypeAttribute, ok := attributes["media_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`media_type is missing from object`)

		return nil, diags
	}

	mediaTypeVal, ok := mediaTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`media_type expected to be basetypes.StringValue, was: %T`, mediaTypeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuxiliaryRomsValue{
		Digest:    digestVal,
		MediaType: mediaTypeVal,
		Size:      sizeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAuxiliaryRomsValueNull() AuxiliaryRomsValue {
	return AuxiliaryRomsValue{
		state: attr.ValueStateNull,
	}
}

func NewAuxiliaryRomsValueUnknown() AuxiliaryRomsValue {
	return AuxiliaryRomsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuxiliaryRomsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuxiliaryRomsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuxiliaryRomsValue Attribute Value",
				"While creating a AuxiliaryRomsValue value, a missing attribute value was detected. "+
					"A AuxiliaryRomsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuxiliaryRomsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuxiliaryRomsValue Attribute Type",
				"While creating a AuxiliaryRomsValue value, an invalid attribute value was detected. "+
					"A AuxiliaryRomsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuxiliaryRomsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuxiliaryRomsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuxiliaryRomsValue Attribute Value",
				"While creating a AuxiliaryRomsValue value, an extra attribute value was detected. "+
					"A AuxiliaryRomsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuxiliaryRomsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuxiliaryRomsValueUnknown(), diags
	}

	digestAttribute, ok := attributes["digest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`digest is missing from object`)

		return NewAuxiliaryRomsValueUnknown(), diags
	}

	digestVal, ok := digestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`digest expected to be basetypes.StringValue, was: %T`, digestAttribute))
	}

	mediaTypeAttribute, ok := attributes["media_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`media_type is missing from object`)

		return NewAuxiliaryRomsValueUnknown(), diags
	}

	mediaTypeVal, ok := mediaTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`media_type expected to be basetypes.StringValue, was: %T`, mediaTypeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewAuxiliaryRomsValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewAuxiliaryRomsValueUnknown(), diags
	}

	return AuxiliaryRomsValue{
		Digest:    digestVal,
		MediaType: mediaTypeVal,
		Size:      sizeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAuxiliaryRomsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuxiliaryRomsValue {
	object, diags := NewAuxiliaryRomsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuxiliaryRomsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuxiliaryRomsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuxiliaryRomsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuxiliaryRomsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuxiliaryRomsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuxiliaryRomsValueMust(AuxiliaryRomsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuxiliaryRomsType) ValueType(ctx context.Context) attr.Value {
	return AuxiliaryRomsValue{}
}

var _ basetypes.ObjectValuable = AuxiliaryRomsValue{}

type AuxiliaryRomsValue struct {
	Digest    basetypes.StringValue `tfsdk:"digest"`
	MediaType basetypes.StringValue `tfsdk:"media_type"`
	Size      basetypes.Int64Value  `tfsdk:"size"`
	state     attr.ValueState
}

func (v AuxiliaryRomsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["digest"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["media_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Digest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["digest"] = val

		val, err = v.MediaType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["media_type"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuxiliaryRomsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuxiliaryRomsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuxiliaryRomsValue) String() string {
	return "AuxiliaryRomsValue"
}

func (v AuxiliaryRomsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"digest":     basetypes.StringType{},
		"media_type": basetypes.StringType{},
		"size":       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"digest":     v.Digest,
			"media_type": v.MediaType,
			"size":       v.Size,
		})

	return objVal, diags
}

func (v AuxiliaryRomsValue) Equal(o attr.Value) bool {
	other, ok := o.(AuxiliaryRomsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Digest.Equal(other.Digest) {
		return false
	}

	if !v.MediaType.Equal(other.MediaType) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v AuxiliaryRomsValue) Type(ctx context.Context) attr.Type {
	return AuxiliaryRomsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuxiliaryRomsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"digest":     basetypes.StringType{},
		"media_type": basetypes.StringType{},
		"size":       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = KernelType{}

type KernelType struct {
	basetypes.ObjectType
}

func (t KernelType) Equal(o attr.Type) bool {
	other, ok := o.(KernelType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KernelType) String() string {
	return "KernelType"
}

func (t KernelType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	digestAttribute, ok := attributes["digest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`digest is missing from object`)

		return nil, diags
	}

	digestVal, ok := digestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`digest expected to be basetypes.StringValue, was: %T`, digestAttribute))
	}

	mediaTypeAttribute, ok := attributes["media_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`media_type is missing from object`)

		return nil, diags
	}

	mediaTypeVal, ok := mediaTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`media_type expected to be basetypes.StringValue, was: %T`, mediaTypeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KernelValue{
		Digest:    digestVal,
		MediaType: mediaTypeVal,
		Size:      sizeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewKernelValueNull() KernelValue {
	return KernelValue{
		state: attr.ValueStateNull,
	}
}

func NewKernelValueUnknown() KernelValue {
	return KernelValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKernelValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KernelValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KernelValue Attribute Value",
				"While creating a KernelValue value, a missing attribute value was detected. "+
					"A KernelValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KernelValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KernelValue Attribute Type",
				"While creating a KernelValue value, an invalid attribute value was detected. "+
					"A KernelValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KernelValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KernelValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KernelValue Attribute Value",
				"While creating a KernelValue value, an extra attribute value was detected. "+
					"A KernelValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KernelValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKernelValueUnknown(), diags
	}

	digestAttribute, ok := attributes["digest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`digest is missing from object`)

		return NewKernelValueUnknown(), diags
	}

	digestVal, ok := digestAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`digest expected to be basetypes.StringValue, was: %T`, digestAttribute))
	}

	mediaTypeAttribute, ok := attributes["media_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`media_type is missing from object`)

		return NewKernelValueUnknown(), diags
	}

	mediaTypeVal, ok := mediaTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`media_type expected to be basetypes.StringValue, was: %T`, mediaTypeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewKernelValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewKernelValueUnknown(), diags
	}

	return KernelValue{
		Digest:    digestVal,
		MediaType: mediaTypeVal,
		Size:      sizeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewKernelValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KernelValue {
	object, diags := NewKernelValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKernelValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KernelType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKernelValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKernelValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKernelValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKernelValueMust(KernelValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KernelType) ValueType(ctx context.Context) attr.Value {
	return KernelValue{}
}

var _ basetypes.ObjectValuable = KernelValue{}

type KernelValue struct {
	Digest    basetypes.StringValue `tfsdk:"digest"`
	MediaType basetypes.StringValue `tfsdk:"media_type"`
	Size      basetypes.Int64Value  `tfsdk:"size"`
	state     attr.ValueState
}

func (v KernelValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["digest"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["media_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Digest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["digest"] = val

		val, err = v.MediaType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["media_type"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KernelValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KernelValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KernelValue) String() string {
	return "KernelValue"
}

func (v KernelValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"digest":     basetypes.StringType{},
		"media_type": basetypes.StringType{},
		"size":       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"digest":     v.Digest,
			"media_type": v.MediaType,
			"size":       v.Size,
		})

	return objVal, diags
}

func (v KernelValue) Equal(o attr.Value) bool {
	other, ok := o.(KernelValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Digest.Equal(other.Digest) {
		return false
	}

	if !v.MediaType.Equal(other.MediaType) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v KernelValue) Type(ctx context.Context) attr.Type {
	return KernelType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KernelValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"digest":     basetypes.StringType{},
		"media_type": basetypes.StringType{},
		"size":       basetypes.Int64Type{},
	}
}
